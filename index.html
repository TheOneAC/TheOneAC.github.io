<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="7989000bfd4e43ea" />










  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Algorithm Git C++" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="生如逆旅  一苇可航">
<meta property="og:type" content="website">
<meta property="og:title" content="TheOneAC">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="TheOneAC">
<meta property="og:description" content="生如逆旅  一苇可航">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TheOneAC">
<meta name="twitter:description" content="生如逆旅  一苇可航">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> TheOneAC </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TheOneAC</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">init</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/APUE第五章：标准IO库/" itemprop="url">
                  APUE第五章：标准IO库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-12-12T19:36:47+08:00" content="2016-12-12">
              2016-12-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/unix/" itemprop="url" rel="index">
                    <span itemprop="name">unix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="5-2流和file对象"><a href="#5-2流和file对象" class="headerlink" title="5.2流和file对象"></a>5.2流和file对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;wchar.h&gt;</div><div class="line">int fwide(FILE *fp, int mode);</div><div class="line">Returns: positive if stream is wide oriented,negative if stream is byte oriented,or 0 if stream has no orientation</div></pre></td></tr></table></figure>
<ul>
<li>mode 负：字节定向，mode 正:宽字节定向， mode 0：不设置流定向但是返回流定向值</li>
</ul>
<h4 id="5-4缓冲"><a href="#5-4缓冲" class="headerlink" title="5.4缓冲"></a>5.4缓冲</h4><pre><code>IO缓冲方式：全缓冲（缓冲区满存入磁盘），行缓冲（收到换行符存入磁盘），不带缓冲
</code></pre><blockquote>
<ol>
<li>标准错误不缓冲</li>
<li>终端设备行缓冲</li>
<li>其他全缓冲</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">void setbuf(FILE *restrict fp, char *restrict buf );</div><div class="line">int setvbuf(FILE *restrict fp, char *restrict buf, int mode,size_t size);</div><div class="line">        Returns: 0 if OK, nonzero on error</div><div class="line">fp: 已打开的文件指针</div><div class="line">buf:未未指定缓冲的流指定缓冲区</div><div class="line">size： 制定的缓冲区大小</div><div class="line">mode：</div><div class="line"> * _IOFBF   全缓冲</div><div class="line"> * _IOLBF   行缓冲</div><div class="line"> * _IONBF   不缓冲</div></pre></td></tr></table></figure>
<h4 id="5-5-打开流"><a href="#5-5-打开流" class="headerlink" title="5.5 打开流"></a>5.5 打开流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">FILE *fopen(const char *restrict pathname, const char *restrict type);</div><div class="line">FILE *freopen(const char *restrict pathname, const char *restrict type,FILE *restrict fp);</div><div class="line">FILE *fdopen(int fd, const char *type);</div><div class="line">All three return: file pointer if OK, NULL on error</div></pre></td></tr></table></figure>
<ul>
<li>fopen 指定方式读取pathname路径名指定的文件</li>
<li>freopen 指定流上打开指定文件</li>
<li>fdopen 关联一和IO流和一个指定文件指针</li>
</ul>
<h4 id="5-6-读写流"><a href="#5-6-读写流" class="headerlink" title="5.6 读写流"></a>5.6 读写流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int getc(FILE *fp);</div><div class="line">int fgetc(FILE *fp);</div><div class="line">int getchar(void);</div><div class="line">All three return: next character if OK, EOF on end of file or error</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int ferror(FILE *fp);</div><div class="line">int feof(FILE *fp);</div><div class="line">Both return: nonzero (true) if condition is true, 0 (false) otherwise</div><div class="line">void clearerr(FILE *fp);</div></pre></td></tr></table></figure>
<ul>
<li><p>每个问价对象维护一个出错标志和一个结束标志，clearerr清除这两个标志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int ungetc(int c, FILE *fp);</div><div class="line">        Returns: c if OK, EOF on error</div></pre></td></tr></table></figure>
</li>
<li><p>字符压回流中，顺序与读出相反（暂时写回缓冲区，并未写回磁盘）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int putc(int c, FILE *fp);</div><div class="line">int fputc(int c, FILE *fp);</div><div class="line">int putchar(int c);</div><div class="line">            All three return: c if OK, EOF on error</div></pre></td></tr></table></figure>
<ul>
<li>行读入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">char *fgets(char *restrict buf, int n, FILE *restrict fp);</div><div class="line">char *gets(char *buf );</div><div class="line">Both return: buf if OK, NULL on end of file or error</div><div class="line">int fputs(const char *restrict str, FILE *restrict fp);</div><div class="line">int puts(const char *str);</div><div class="line">Both return: non-negative value if OK, EOF on error</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-9-二进制IO"><a href="#5-9-二进制IO" class="headerlink" title="5.9 二进制IO"></a>5.9 二进制IO</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">size_t fread(void *restrict ptr, size_t size, size_t nobj,FILE *restrict fp);</div><div class="line">size_t fwrite(const void *restrict ptr, size_t size, size_t nobj,FILE *restrict fp);</div><div class="line">                            Both return: number of objects read or written</div><div class="line">size : object size</div><div class="line">nobj : number of object</div></pre></td></tr></table></figure>
<h4 id="5-10-定位流"><a href="#5-10-定位流" class="headerlink" title="5.10 定位流"></a>5.10 定位流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">long ftell(FILE *fp);</div><div class="line">                    Returns: current file position indicator if OK, .1L on error</div><div class="line">int fseek(FILE *fp, long offset, int whence);</div><div class="line">                    Returns: 0 if OK, .1 on error</div><div class="line">void rewind(FILE *fp); 流指针返回初始位置</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int fgetpos(FILE *restrict fp, fpos_t *restrict pos);</div><div class="line">将文件位置指示器存入pos</div><div class="line">int fsetpos(FILE *fp, const fpos_t *pos);</div><div class="line">将文件位置指示器设置为pos</div><div class="line">            Both return: 0 if OK, nonzero on error</div></pre></td></tr></table></figure>
<h4 id="5-11格式化IO"><a href="#5-11格式化IO" class="headerlink" title="5.11格式化IO"></a>5.11格式化IO</h4><ul>
<li><p>output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int printf(const char *restrict format, ...);</div><div class="line">int fprintf(FILE *restrict fp, const char *restrict format, ...);</div><div class="line">int dprintf(int fd, const char *restrict format, ...);</div><div class="line">                All three return: number of characters output if OK, negative value if output error</div><div class="line">int sprintf(char *restrict buf, const char *restrict format, ...);</div><div class="line">                Returns: number of characters stored in array if OK, negative value if encoding error</div><div class="line">int snprintf(char *restrict buf, size_t n,const char *restrict format, ...);</div><div class="line">                Returns: number of characters that would have been stored in array</div><div class="line">                    if buffer was large enough, negative value if encoding error</div></pre></td></tr></table></figure>
</li>
<li><p>input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int scanf(const char *restrict format, ...);</div><div class="line">int fscanf(FILE *restrict fp, const char *restrict format, ...);</div><div class="line">int sscanf(const char *restrict buf, const char *restrict format, ...);</div><div class="line">            All three return: number of input items assigned,EOF if input error or end of file before any conversion</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/12/inside-the-c-model/" itemprop="url">
                  inside the c++ model
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-12-12T19:31:22+08:00" content="2016-12-12">
              2016-12-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一章关于对象"><a href="#第一章关于对象" class="headerlink" title="第一章关于对象"></a>第一章关于对象</h3><blockquote>
<ul>
<li>c++在布局和存取时间的额外负担主要有virtual引起<ul>
<li>virtual function：运行期动态绑定</li>
<li>virtual base class ：base class多次出现在派生类中，但只有一个单一而被共享的实体（虚基类）<ul>
<li>对象模型</li>
<li>简单模型：每一个地址slot指向一个成员，</li>
<li>表格模型：数据表和成员函数表</li>
</ul>
<ol>
<li>数据表包含数据本身</li>
<li>成员函数表包含指向每个成员函数的指针slot</li>
</ol>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>虚函数表</p>
<ul>
<li>每个class产生一堆指向virtual function的指针，，指针形成一个virtual function table；</li>
<li>每一个class object 添加一个指向virtual function table 的指针vptr</li>
<li>每一个class 关联一个type_info object由虚函数表指出<blockquote>
<p> <code>被指定的object在执行点之前是无法确定类型的，必须通过指针或者引用操作实现</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>c++支持多态的方式</p>
<ul>
<li>隐含转化操作，子类指针赋值给父类指针</li>
<li>virtual function</li>
<li>dynamic_cast 和 typeid</li>
<li>基类定义接口，通过virtual function方式，在运行时确定object类型并执行相应操作</li>
</ul>
</li>
</ul>
<h3 id="第二章-构造函数"><a href="#第二章-构造函数" class="headerlink" title="第二章 构造函数"></a>第二章 构造函数</h3><h4 id="2-1-default-constructor-的构建"><a href="#2-1-default-constructor-的构建" class="headerlink" title="2.1 default constructor 的构建"></a>2.1 default constructor 的构建</h4><blockquote>
<ul>
<li>生成default constructor 的要素：<ul>
<li>含有member object 且member object 均有default constructor</li>
<li>class本身无任何constructor，则调用constructor 时编辑器将为class合成一个default constructor</li>
<li>以member objects 在class 声明次序调用各个member object 的 default constructor<br><code>如果derived class 拥有多个constructor 但是没有default constructor，编译器将扩张每一个consturctor，加入每一个必要的基类default constructor,但不会再合成default constructor</code></li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="2-1-1“带有default-constructor-”的base-class-："><a href="#2-1-1“带有default-constructor-”的base-class-：" class="headerlink" title="2.1.1“带有default constructor ”的base class  ："></a>2.1.1“带有default constructor ”的base class  ：</h6><blockquote>
<ul>
<li>自动合成default constructor<pre><code>- class 声明（继承）一个virtual function
- class 派生自一个继承串联，其中至少一个virtual base class
</code></pre></li>
<li>自动合成过程<ul>
<li>产生一个virtual function table，内放class的virtual functions 地址</li>
<li>每一个class object合成一个pointer（vptr）只想class 的virtual function table<br><code>已定义constructor则扩展，未定义则合成default constructor， 保证正确初始化每一个class object 的vptr</code></li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="2-1-2“带有一个virtual-base-class”的class"><a href="#2-1-2“带有一个virtual-base-class”的class" class="headerlink" title="2.1.2“带有一个virtual base class”的class"></a>2.1.2“带有一个virtual base class”的class</h6><blockquote>
<ul>
<li>在derived class object 的每一个virtual base class 中插入一个指向，经由pointer 和reference 存取virtual base class 的操作由这个指针完整（指向同一份内容）<ul>
<li>已定义constructor则扩展，未定义则合成default constructor， 保证允许每一个virtual base class 执行器存取操作</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>summary:合成 implicit nontrivial default constructor<ul>
<li>借用member object 或者 base class 的default constructor</li>
<li>为每一个object 初始化virtual function机制 或者 virtual base机制 </li>
<li>除以上以外，如无任何声明constructor 则不会合成default constructor</li>
</ul>
</li>
<li>合成的default constructor 中只有base class objects 和member class objects 被初始化</li>
</ul>
<p>####2.2 copy constructor 的构建</p>
<blockquote>
<ul>
<li>执行copy constructor的三种情况：<pre><code>- 赋值
- 作为参数传递
- 作为返回值
</code></pre></li>
<li>default memberwise initialization<ul>
<li>对于member data 逐一赋值</li>
<li>对于member function 递归调用 memberwise initialization</li>
</ul>
</li>
<li>当class 不展现一个“bitewise copy semantics”(如下四种情况)，需要合成copy constructor<ol>
<li>class 内包含一个member object 且后者（声明或者合成）copy constrctor 时</li>
<li>class 继承一个base class 且后者（声明或者合成）copy constrctor 时</li>
<li>class 声明至少一个virtual function时</li>
<li>class 派生自一个继承串联，其中至少一个virtual base class</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="2-3-program-transformation-semantics"><a href="#2-3-program-transformation-semantics" class="headerlink" title="2.3 program transformation semantics"></a>2.3 program transformation semantics</h4><blockquote>
<ul>
<li>explicit initialization:直接逐位赋值member data<ul>
<li>argument initialization:参数构造临时对象并copy constrcuct</li>
<li>copy construct and 返回引用</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2-4-member-initialization-list"><a href="#2-4-member-initialization-list" class="headerlink" title="2.4 member initialization list"></a>2.4 member initialization list</h4><blockquote>
<ul>
<li>initial 时：= 操作符以arguement初始化对象时分为三步：1、以arguement 构造一个 临时对象，2、将临时对象copy给目标对象，3、销毁临时对象<ul>
<li>初始化顺序是由members声明次序决定的，不是由member list 顺序决定的；</li>
<li>member list 中初始化先于explicit assignment：即：之后的初始化先于{}内部member data的初始化或者赋值<br><code>X::x(int v):j(v){i = j;}j 的初始化先于i的初始化</code></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="第三章-the-semantaic-of-data"><a href="#第三章-the-semantaic-of-data" class="headerlink" title="第三章 the semantaic of data"></a>第三章 the semantaic of data</h3><h4 id="3-1-data-member-绑定"><a href="#3-1-data-member-绑定" class="headerlink" title="3.1 data member 绑定"></a>3.1 data member 绑定</h4><pre><code>- 局域绑定
</code></pre><h4 id="3-2-data-member-layout"><a href="#3-2-data-member-layout" class="headerlink" title="3.2 data member layout"></a>3.2 data member layout</h4><pre><code>- 同一access session 按照声明顺序合并，静态成员不存在class 内部
</code></pre><h4 id="3-3-data-member-存取"><a href="#3-3-data-member-存取" class="headerlink" title="3.3 data member 存取"></a>3.3 data member 存取</h4><pre><code>- static data member 
 &gt; 独立于class 之外，不论是继承virtual base class而来或者函数调用得到的static 都是直接存取，通过指针和通过对象存取是一样的
- nonstatic data member
 &gt; 通过指向对象的指针和对象访问一致的，当访问的member data是一个从virtual base class 继承而来的member时，指针访问在运行时才能确定
- 多重继承
![pointer实现：共享虚基类](http://odfcr7qs4.bkt.clouddn.com/IMG_0073.PNG)
![offset实现：共享虚基类](http://odfcr7qs4.bkt.clouddn.com/IMG_0074.PNG)
</code></pre><h4 id="3-6-pointer-to-data-member"><a href="#3-6-pointer-to-data-member" class="headerlink" title="3.6 pointer to data member"></a>3.6 pointer to data member</h4><pre><code>* &amp;Pointer：：z   “取一个nonstaic data member，得到它在class 中的偏移量”
* &amp;origin.z   “取一个class object 的datamenber地址， 得到member在内存中的真正地址”
* 继承层次越深，指针代码执行速度越慢
</code></pre><h3 id="第四章-the-semantics-of-function"><a href="#第四章-the-semantics-of-function" class="headerlink" title="第四章 the semantics of function"></a>第四章 the semantics of function</h3><h4 id="4-1-member-调用方式"><a href="#4-1-member-调用方式" class="headerlink" title="4.1 member 调用方式"></a>4.1 member 调用方式</h4><pre><code>* nonstatic member function
  〉 0. 安插this指针   
    1. 对nonstatic member function 经由this 指针存取
    2. 将member function 改写成独一无二（name mangling）的外部函数
  - nonstatic member function 与外部函数的访问性能是一样的
* virtual member function
 &gt;  经由对象调用virtual function 被处理为编译绑定，与nonstatic member function的调用方式一致
* static member function
 &gt;  0. 通过指针或者对象调用静态成员函数都被当做一般函数处理
 〉 1. static member function 没有this 指针，被当做一般函数处理
</code></pre><h3 id="第五章-the-semantics-of-construction-destruction-and-copy"><a href="#第五章-the-semantics-of-construction-destruction-and-copy" class="headerlink" title="第五章  the semantics of construction destruction and  copy"></a>第五章  the semantics of construction destruction and  copy</h3><h4 id="5-1-无继承的对象构造"><a href="#5-1-无继承的对象构造" class="headerlink" title="5.1 无继承的对象构造"></a>5.1 无继承的对象构造</h4><blockquote>
<ol>
<li>bitwise member copy<ol>
<li>ADT class 执行default copy constructor，copy constructor， destructor，但是并不产生相应函数</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="5-2-继承体系下的对象构造"><a href="#5-2-继承体系下的对象构造" class="headerlink" title="5.2 继承体系下的对象构造"></a>5.2 继承体系下的对象构造</h4><ul>
<li>vptr 初始化语义学<ul>
<li>在class的constructor 或者 destructor 中调用一个virtual function ，调用的必须是本class 中的那个function实体</li>
</ul>
</li>
</ul>
<ol>
<li>dervied class constructor 中所有virtual base class 和base class constructor 被调用</li>
<li>对象vprt被设置，指向相关virtual function table</li>
<li>member initialization list 在constructor 内部展开</li>
<li>执行程序直接赋值代码和生成对象的代码</li>
</ol>
<ul>
<li>不要在虚基类中声明数据</li>
</ul>
<h4 id="5-5-semantics-of-destructor"><a href="#5-5-semantics-of-destructor" class="headerlink" title="5.5 semantics of destructor"></a>5.5 semantics of destructor</h4><ul>
<li>如果class 未声明destructor 且member object 拥有destructor ，编译器自动合成destructor，否则不合成<blockquote>
<ol>
<li>destructor 函数本身最先执行</li>
<li>member class object 执行自己的destructor</li>
<li>object 每部vptr 重置</li>
<li>直接上层的nonvirtual base class 以其声明的顺序的逆序执行destructor</li>
<li>virtual base class 按照与构造顺序相反的顺序执行destructor</li>
</ol>
</blockquote>
</li>
</ul>
<hr>
<p>后边两章感觉理解不到位啊，缺少实踩代码坑</p>
<h3 id="第六章-runtime-semantics"><a href="#第六章-runtime-semantics" class="headerlink" title="第六章 runtime semantics"></a>第六章 runtime semantics</h3><h4 id="6-2-new-delete-运算符"><a href="#6-2-new-delete-运算符" class="headerlink" title="6.2 new delete 运算符"></a>6.2 new delete 运算符</h4><pre><code>- new 和delete 底层以malloc 和free 实现
- new 失败，必须在new 内部完成已分配空间的释放
</code></pre><h4 id="6-3-临时对象的处理"><a href="#6-3-临时对象的处理" class="headerlink" title="6.3 临时对象的处理"></a>6.3 临时对象的处理</h4><pre><code>- 临时对象的销毁，必须在完整表达式求值过程的最后，该完整表达式造成临时对象的生成
- 如果临时对象被reference 对象将残留到reference 生命周期结束
</code></pre><h3 id="第七章-on-the-cusp-of-the-object-model"><a href="#第七章-on-the-cusp-of-the-object-model" class="headerlink" title="第七章 on the cusp of the object model"></a>第七章 on the cusp of the object model</h3><pre><code>- template
&gt; member function 只在使用时具现出来
- exception handing 快速检阅
&gt; 0. throw 子句，发出exception
  1. 多个catch 子句捕获相应类型的exception
  2. try区段处理
- RTTI
&gt;  dynamic_cast 通过vptr指向type_info运行时判定类型实现转型，比static_cast代价高但是更安全
&gt;  dynamic_cast 应用于pointer 时，安全转型则直接向下转型，不安全则pointer置0
&gt;  dynamic_cast 应用于reference 时，安全转型则直接向下转型，不安全则返回一个bad_cast exception
&gt;  typeid 返回一个 const reference，类型为type_info,
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/leetcode279-Perfect-Squares-basic-dp/" itemprop="url">
                  leetcode279. Perfect Squares(basic dp)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-11-26T22:03:54+08:00" content="2016-11-26">
              2016-11-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OJ/" itemprop="url" rel="index">
                    <span itemprop="name">OJ</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="learn-from-this"><a href="#learn-from-this" class="headerlink" title="learn from this"></a>learn from <a href="https://discuss.leetcode.com/topic/24255/summary-of-4-different-solutions-bfs-dp-static-dp-and-mathematics" target="_blank" rel="external">this</a></h3><ul>
<li><p>DP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int numSquares(int n) &#123;</div><div class="line">        if(n&lt;=0)return 0;</div><div class="line">        int * dp = new int[n+1]();</div><div class="line">        for(int i=1;i&lt;=n;i++)&#123;</div><div class="line">            dp[i]= INT_MAX;</div><div class="line">            for(int j =1;j*j &lt;=i;j++)&#123;</div><div class="line">                int tmp = dp[i-j*j]+1;</div><div class="line">                dp[i]=dp[i]&lt;tmp?dp[i]:tmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //for(int i=0;i&lt;=n;i++)cout&lt;&lt; dp[i]&lt;&lt;&apos; &apos;;</div><div class="line">        return dp[n];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>BFS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int numSquares(int n) &#123;</div><div class="line">        if (n &lt;= 0)return 0;</div><div class="line">        else if(pow((int)sqrt(n),2) == n)return 1;</div><div class="line">        vector&lt;int&gt; perfectSquares;//candinates</div><div class="line">        vector&lt;int&gt; cntPerfectSquares(n);//count_index</div><div class="line">        for (int i = 1; i*i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            perfectSquares.push_back(i*i);</div><div class="line">            cntPerfectSquares[i*i - 1] = 1;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        queue&lt;int&gt; searchQ;</div><div class="line">        for (auto&amp; i : perfectSquares) searchQ.push(i);</div><div class="line">        int currCntPerfectSquares = 1;</div><div class="line">        while (!searchQ.empty())//BFS</div><div class="line">        &#123;</div><div class="line">            currCntPerfectSquares++;</div><div class="line">            </div><div class="line">            int searchQSize = searchQ.size();</div><div class="line">            for (int i = 0; i &lt; searchQSize; i++)</div><div class="line">            &#123;</div><div class="line">                int tmp = searchQ.front();</div><div class="line">                for (auto&amp; j : perfectSquares)</div><div class="line">                &#123;</div><div class="line">                    if (tmp + j == n)return currCntPerfectSquares;</div><div class="line">                    else if ((tmp + j &lt; n) &amp;&amp; (cntPerfectSquares[tmp + j - 1] == 0))</div><div class="line">                    &#123;</div><div class="line">                        cntPerfectSquares[tmp + j - 1] = currCntPerfectSquares;</div><div class="line">                        searchQ.push(tmp + j);</div><div class="line">                    &#125;</div><div class="line">                    else if (tmp + j &gt; n)break;</div><div class="line">                &#125;</div><div class="line">                searchQ.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/Object Oriented in C++/" itemprop="url">
                  Object Oriented in C++
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-11-26T22:00:54+08:00" content="2016-11-26">
              2016-11-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>定义<code>const</code> 成员函数时,<code>const</code> 位于<code>参数</code>与<code>函数体</code>之间</li>
<li><code>const</code>成员函数只能调用 <code>const</code>成员函数,保证不做修改</li>
<li><code>禁用默认函数</code>(构造,赋值构造等),将<code>默认函数私有化</code>private</li>
<li><code>const</code>成员变量只能<code>参数列表初始化</code></li>
<li>成员函数内部<code>static</code>变量为<code>所有调用该成员函数的对象共有</code></li>
<li><code>this</code>指针<code>不用于static 成员函数</code>中,<code>不能指向const 对象</code></li>
<li>隐藏的父类成员,子类不可直接调用,通过父类共有函数调用</li>
<li><code>派生类同名成员或者函数 屏蔽父类同名成员或者函数</code></li>
<li>为<code>基类设置默认构造函数</code>,方便子类继承</li>
<li>基类声明虚函数后,<code>子类同名</code>自动定义为<code>虚函数</code></li>
<li>构造函数<code>不可以是虚成员函数</code>, <code>析构函数</code>可以</li>
<li><code>重载</code>在<code>编译时期绑定</code>,<code>虚函数(多态)</code> <code>运行期间绑定</code></li>
<li><code>覆盖</code>:多态虚函数函数签名相同,  <code>遮蔽</code>: 共享函数名但签名不同</li>
<li><code>抽象基类确保派生类必须定义某些特定函数（纯虚函数）</code>，否则派生类不可以实例化</li>
<li>抽象基类：<code>包含一个纯虚函数　　virtual    =0;</code></li>
<li><p><code>抽象基类不可实例化</code>，可派生，其<code>派生类必须覆盖全部纯虚函数</code>才可被实例化</p>
</li>
<li><p>重载不改变符号优先级</p>
</li>
<li>除<code>new new[] delete delete[]</code>外以顶层函数重载操作符必须包含一个类对象</li>
<li>操作符<code>[] ()　-&gt;</code>必须以<code>类成员形式重载</code></li>
<li>以成员函数重载二元操作符，只需一个参数，而以顶层函数重载二元操作符时必须两个参数</li>
<li>使用<code>顶层函数重载非对象操作数可出现在操作符左边</code>，<code>类成员函数重载</code>时<code>第一个操作数必须是类对象</code><br>-　<code>praivete member</code> only access by <code>menberfunction and friend funtion.</code></li>
<li><code>protect member</code> can be accessed by <code>menber funtion</code>, <code>friend function</code> and <code>member function of derived class</code></li>
<li>using <code>friend function</code> <code>only</code> in <code>overloading operator</code> as possible as we can</li>
<li>前置自增：　operator++()     后置自增：　operator++(int );</li>
<li><code>new new[]</code>  <code>return type</code> must be <code>void*</code>, the first parameter must be <code>size_t</code></li>
<li><code>delete delete[]</code> return type must be <code>void*</code>, the first parameter must be <code>void *</code> wihch point to the object need to destroied</li>
<li><p>对象不能属于模板类，只能属于模板类实例</p>
</li>
<li><p>duque :双端插入删除效率一致，vector 尾部插入删除效率高</p>
</li>
<li><code>protect</code>成员只能被<code>该类和子类的方法访问</code></li>
<li>父类成员必须定义默认构造函数，否则子类构造前出现编译错误</li>
<li>同一域名空间，函数名相同，签名不同</li>
<li>编译期绑定确定绑定函数，也称为静态多态<h4 id="重写-覆盖-override"><a href="#重写-覆盖-override" class="headerlink" title="重写:覆盖(override)"></a>重写:覆盖(override)</h4></li>
<li>虚函数</li>
<li>子类空间，函数名相同，签名相同<h4 id="重定义：遮蔽（redefine）"><a href="#重定义：遮蔽（redefine）" class="headerlink" title="重定义：遮蔽（redefine）"></a>重定义：遮蔽（redefine）</h4></li>
<li>非虚函数，子类成员函数与父类成员函数同名</li>
<li>虚函数，子类成员函数与父类成员函数同名但不同签名<h4 id="多态：（动态多态）"><a href="#多态：（动态多态）" class="headerlink" title="多态：（动态多态）"></a>多态：（动态多态）</h4></li>
<li>运行期确定绑定对象，也称为动态多态</li>
<li>同签名虚函数构成覆盖</li>
<li>父类指针指向子类对象，调用属于子类的函数</li>
</ul>
<hr>
<ul>
<li>顶层函数重载操作符<ul>
<li>非对象操作数可以出现在操作符左边</li>
<li>使用类成员函数重载是，第一操作数必须是累的对象</li>
<li>顶层函数不能直接访问类私有成员，最好将顶层重载函数设为友元函数，方便直接访问私有数据成员</li>
</ul>
</li>
<li>重载[]:  重载为成员函数，检查下标 ， 返回一个引用适应左值情况</li>
<li>重载（）： 函数调用重载操作符</li>
<li>析构函数出现，必须定义拷贝构造，赋值构造函数</li>
</ul>
<hr>
<ul>
<li>继承下的构造函数：<ul>
<li>先父类按继承顺序构造，再成员按顺序构造，最后派生类构造</li>
<li>每一层只负责调用父类构造函数</li>
<li>基类没有默认构造时，子类构造函数必须显式调用基类的某个构造函数</li>
<li>创建派生类对象时，自动调用基类默认构造函数<ul>
<li>子类有构造函数，基类没有默认构造，创建子类对象时，自动创建基类默认构造函数</li>
<li>子类没有构造函数，基类有默认构造，创建子类对象时，自动调用基类默认构造</li>
<li>子类有构造函数，基类也有默认构造，创建子类对象时，直接调用基类默认构造，或者调用子类显式调用的构造函数</li>
<li>子类基类均有构造，但是基类没有默认构造，创建子类对象时，必须显式调用基类构造函数</li>
</ul>
</li>
</ul>
</li>
<li>继承下的析构函数: 定义实现对派生类新增成员的析构释放</li>
<li>虚基类构造优先于非虚基类的构造</li>
<li>虚基类构造由最派生类调用，其他派生类跳过对虚基类构造的调用</li>
<li>派生类对象和指针可适用于任何基类对象或指针使用的位置（子类可以向上转型）</li>
<li>赋值兼容：子类对象可以赋值或者初始化父类对象，基类指针可以指向子类对象地址</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/25/TCP协议簇/" itemprop="url">
                  TCP协议簇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-25T10:41:48+08:00" content="2016-10-25">
              2016-10-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h4><blockquote>
<h6 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h6><ul>
<li>比特流传输</li>
<li>比特同步、物理拓扑</li>
<li>传输方式：半双工、双工<h6 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h6></li>
<li>节点间帧传输</li>
<li>组帧</li>
<li>加入物理地址</li>
<li>流量控制：发送速度小于接受速度</li>
<li>接入控制：决定链路控制权</li>
<li>确保组网内部节点间传递<h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6></li>
<li>确保源点到终点间的分组交付</li>
<li>路由选择</li>
<li>点点交付<h6 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h6></li>
<li>报文源点到终点的端端交付</li>
<li>分段与重装<h6 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h6></li>
<li>会话控制与同步<h6 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h6></li>
<li>编码转换</li>
<li>信息加密与压缩<h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6></li>
<li>虚拟终端</li>
<li>文件传输与管理</li>
<li>邮件服务和名录服务<br><img src="http://odfcr7qs4.bkt.clouddn.com/%E5%9B%BE2.14.PNG" alt="图2.14"></li>
<li>以太网数据帧长46~1500字节</li>
<li>隐蔽站问题：先发一个请求服务帧（RTS），请求服务时间，接收站广播(CTS)在服务时间内只为请求站服务</li>
<li>中继器：连接同一子网的不同网段</li>
<li>集线器：多端口转发</li>
<li>网桥：工作在链路层，检查MAC地址，过滤帧转发地址</li>
<li>透明网桥： 帧转发，自学习，避免环路</li>
<li>路由器转发会修改物理地址，工作在网络层，<ul>
<li>整个传递过程目的IP地址不变</li>
<li>路由器接受前，目的物理地址是路由器地址</li>
<li>接收后转发，源物理地址是路由器物理地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">网络地址：主机位全0</div><div class="line">直接广播地址：主机位全1</div><div class="line">受限广播地址：全1</div><div class="line">这个网络这个主机：全0</div><div class="line">这个网络特定主机：网络位全0</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>路由表</p>
<ul>
<li>目的网络地址：使用特定网络地址转发</li>
<li>下一跳地址：直接交付时为空</li>
<li>接口位置：定义转发接口</li>
<li>目的地址查找成功，ARP映射获得物理地址，帧转发到下一跳<pre><code>        OP 源MAC 源IP 目的MAC 目的IP
ARP请求： 1  *      *            *
ARP响应： 2  *      *     *      *
RARP请求： 3  *
RARP响应： 4  *      *     *      *
</code></pre><img src="http://odfcr7qs4.bkt.clouddn.com/%E5%9B%BE8.10IP%E9%80%89%E9%A1%B9.PNG" alt="图8.10IP选项格式"><br>IP报文总长20~65535，首部长：20~60字节<br>总长以1字为单位，首部 长以4字节为单位<br>分片偏移以8字为单位，相对于原始数据包起点</li>
<li>IP协议字段：1 ICMP 2 IGMP 6 TCP 17：UDP 89 OSPF<br><img src="http://odfcr7qs4.bkt.clouddn.com/%E5%9B%BE9.1ICMP%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B.PNG" alt="图9.1ICMP报文类型"></li>
<li>差错报文发送给原始数据源</li>
<li>对差错报文不再发送差多报文</li>
<li>对多播报文不发送差错报文</li>
<li>分片数据报的非首片不发送差错报文</li>
<li>特殊地址数据报不发送差错报文<br>每一个因为拥塞丢弃的报文都向源点发送源点抑制报文<br>ICMP协议为IP协议提供：</li>
<li>差错报告、差错控制（重点不可达，超时、源点抑制、参数问题、改变路由）、</li>
<li>主机管理查询（回送送请求和响应、时间戳请求与响应）、</li>
<li>流量控制（源点抑制报文）服务</li>
</ul>
</blockquote>
<p>发送超时报文：</p>
<ul>
<li>（路由器发送）收到的报文TTL字段为0，</li>
<li>（目的主机发送）规定时间内未收到报文的某个分片<br>改变路由报文：路由器向主机发送改变路由报文<br>回送请求和回送回答报文用于测试主机可达性确认网络层通信是否正常<br>时间戳请求与回答：确认往返时间，机器间时间同步<br>ping利用回送请求与响应报文实现<br>traceroute利用超时报文（中间TTL减少至0，路由器发回超时）和终点不可达报文（UDP端口异常）</li>
<li>ICMP 报文类型：查询、成员关系报告、推出报告</li>
<li>成员关系报告需要连续发送两次</li>
<li>成员关系报告：加入组</li>
<li>退出报告：退出一个组</li>
<li>一般性查询：多播路由器周期性发送以监视成员关系</li>
<li>延迟响应：主机等待随机时间，该时间内若有成员关系报告广播，就不再对这个组发送成员关系响应广播<br>携带ICMP报文的IP报文中：协议字段为2，TTL必须是1（局域网内）<br>目的IP地址：查询（多播）：224.0.0.1，成员关系报告（广播）：这个组的多播地址，退出报告（多播）：224.0.0.2<br>####### 数据链路层MAC地址映射：</li>
<li>多播路由器提取D类IP地址的低23位插入以太网多播地址中</li>
<li>D类IP地址组标识共28位，取23位映射以太网多播地址，位未使用，32-&gt;1</li>
<li>以太网多播地址范围：01:00:5E:00:00:00 ~ 01:00:5E:7F:FF:FF</li>
<li>广域网不支持物理多播地址，只能采用隧道技术，封装成单播，到达局域网后解析成多播<br>####### UDP<br>熟知端口号:0~1023,注册端口号：1024~49151，动态端口号：49152~65535<br>UDP长度 = IP长度-IP首部长度<h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6></li>
<li>编号从随机数开始</li>
<li>报文序号：首字节序号</li>
<li>确认号：期望接收的下一个序号</li>
<li>SYN 和SYN+ACK报文不携带数据，消耗一个序号</li>
<li>ACK不携带数据则不消耗序号<br><img src="" alt="12.9"><br><img src="" alt="12.11"></li>
<li>FIN不消耗序号，FIN+ACK只消耗一个序号</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/APUE-Process/" itemprop="url">
                  APUE Process
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-10T16:40:03+08:00" content="2016-10-10">
              2016-10-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Process/" itemprop="url" rel="index">
                    <span itemprop="name">Process</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="chapter-seven"><a href="#chapter-seven" class="headerlink" title="chapter seven"></a>chapter seven</h5><ul>
<li><p>Process tremination</p>
<blockquote>
<ul>
<li>Return from main</li>
<li>Calling exit</li>
<li>Calling _exit or _Exit</li>
<li>Return of the last thread from its start routine</li>
<li>Calling pthread_exit</li>
<li>from the last thread</li>
</ul>
<ul>
<li><code>Abnormal termination occurs in three ways:</code><ul>
<li>Calling abort (Section 10.17)</li>
<li>Receipt of a signal (Section 10.2)</li>
<li>Response of the last thread to a cancellation request</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>Exit Functions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">void exit(int status);</div><div class="line">void _Exit(int status);</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">void _exit(int status);</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>_exit</code> and <code>_Exit</code>, which <code>return</code> to the kernel <code>immediately</code>, and <code>exit</code>, which <code>performs certain cleanup processing</code>and then returns to the kernel.</p>
</blockquote>
<ul>
<li>atexit()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">int atexit(void (*func)(void));</div><div class="line">Returns: 0 if OK, nonzero on error</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li>a process can register at least 32 functions that are automatically called by exit. These are called exit handlers and are registered by calling the atexit function.</li>
<li>The exit function calls these functions in reverse order of their registration.</li>
<li>Each function is called as many times as it was registered.</li>
<li>Environment List<br><img src="" alt="Environment"><br>the environment strings are typically stored at the top<br>of a process’s memory space, above the stack.</li>
</ul>
</blockquote>
<h5 id="chapter-eight"><a href="#chapter-eight" class="headerlink" title="chapter eight"></a>chapter eight</h5><ul>
<li>pid_t<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">pid_t getpid(void);</div><div class="line">Returns: process ID of calling process</div><div class="line">pid_t getppid(void);</div><div class="line">Returns: parent process ID of calling process</div><div class="line">uid_t getuid(void);</div><div class="line">Returns: real user ID of calling process</div><div class="line">uid_t geteuid(void);</div><div class="line">Returns: effective user ID of calling process</div><div class="line">gid_t getgid(void);</div><div class="line">Returns: real group ID of calling process</div><div class="line">gid_t getegid(void);</div><div class="line">Returns: effective group ID of calling process</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a><code>fork</code></h4><p>-　调用一次，返回两次，子进程返回０，　父进程返回子线程pid<br>-　子进程只保留调用fork 的线程副本<br>-　父进程中所有打开的文件描述符被复制到子进程<br>-　子进程不集成父进程的文件锁，<code>未处理闹钟清除，未处理信号集置空</code><br>-　父进程先于子进程结束，子进程被<code>init</code>进程收养，其父进程ＩＤ为１<br>-　已经结束但未被父进程处理的进程：<code>僵死进程</code></p>
<h4 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait waitpid"></a><code>wait</code> <code>waitpid</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">pid_t wait(int *statloc);</div><div class="line">pid_t waitpid(pid_t pid, int *statloc, int options);</div><div class="line">Both return: process ID if OK, 0 (see later), or −1 on error</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>wait or waitpid do<br>• <code>Block</code>, if <code>all of its children are still running</code><br>• <code>Return immediately</code> with the termination status of <code>a child</code>, if a child has terminated and is waiting for its termination status to be fetched<br>• <code>Return immediately with an error</code>, if it <code>doesn’t have any child</code> processes</li>
<li>OSIX.1 waitpid function.<br>The interpretation of the pid argument for waitpid depends on its value:</li>
<li>pid == −1  <code>Waits for any child process</code>. In this respect, waitpid is equivalent to wait.</li>
<li>pid &gt; 0 <code>Waits for the child whose process ID equals pid</code>.</li>
<li>pid == 0 Waits for <code>any child</code> whose process <code>group ID</code> equals that of the calling process.</li>
<li>pid &lt; −1 Waits for <code>any child</code> whose process <code>group ID</code> equals the absolute value of pid</li>
</ul>
</blockquote>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int execl(const char *pathname, const char *arg0, ... /* (char *)0 */ );</div><div class="line">int execv(const char *pathname, char *const argv[]);</div><div class="line">int execle(const char *pathname, const char *arg0, ...</div><div class="line">/* (char *)0, char *const envp[] */ );</div><div class="line">int execve(const char *pathname, char *const argv[], char *const envp[]);</div><div class="line">int execlp(const char *filename, const char *arg0, ... /* (char *)0 */ );</div><div class="line">int execvp(const char *filename, char *const argv[]);</div><div class="line">int fexecve(int fd, char *const argv[], char *const envp[]);</div><div class="line">All seven return: −1 on error, no return on success</div></pre></td></tr></table></figure>
<blockquote>
<p><code>l</code> stands for <code>list</code>, <code>v</code> stands for <code>vector</code>, <code>e</code> stands for <code>environment</code><br>The functions <code>execl, execlp, and execle</code> require <code>each of the
command-line arguments</code> to the new program to be specified as separate arguments. We <code>mark the end of the arguments</code> with <code>a null pointer</code>.<br>For the other four functions (<code>execv, execvp, execve, and fexecve</code>), build an array of pointers to the arguments, and <code>the address of this array</code> pass to these three functions.<br><img src="" alt="exec"></p>
</blockquote>
<h4 id="Process-schedule"><a href="#Process-schedule" class="headerlink" title="Process schedule"></a><code>Process schedule</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int nice(int incr);</div><div class="line">#include &lt;sys/resource.h&gt;</div><div class="line">int getpriority(int which, id_t who);</div><div class="line">Returns: new nice value − NZERO if OK, −1 on error</div><div class="line">#include &lt;sys/resource.h&gt;</div><div class="line">int setpriority(int which, id_t who, int value);</div><div class="line">Returns: 0 if OK, −1 on error</div></pre></td></tr></table></figure>
<blockquote>
<p>which : PRO_PROCESS , PRO_GROUP, PRO_USER</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/Network-programming-csapp/" itemprop="url">
                  Network programming csapp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-10T11:19:22+08:00" content="2016-10-10">
              2016-10-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Network-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Network Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>IP 地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct in_addr&#123;</div><div class="line">	unsigned int s_addr</div><div class="line">&#125;</div><div class="line">#include &lt;netinet/in.h&gt;</div><div class="line">unsigned long int  htonl(unsigned long int hostlong);</div><div class="line">unsigned short int  htons(unsigned short int hostshort);</div><div class="line">本地转网络字节序</div><div class="line">unsigned long int ntohl(unsigned long int hostlong);</div><div class="line">unsigned short int ntohs(unsigned short int hostlong);</div><div class="line">网络转本地字节</div><div class="line">均以无符号数转换</div><div class="line">网络字节摩恩为：大端，即有效地位存放在地址高位</div><div class="line">＃include&lt;arpa/inet.h&gt;</div><div class="line">int inet_aton((const char*cp, struct in_addr *inp);</div><div class="line">点分十进制串(cp)转网络字节序IP(inp)</div><div class="line">int inet_ntoa (struct in_addr in);</div><div class="line">网络字节序IP 转点分十进制</div></pre></td></tr></table></figure>
</li>
<li><p>Domain structure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;netdb.h&gt;</div><div class="line">struct host&#123;</div><div class="line">	char *h_name;        // domain name</div><div class="line">    char **h_aliases;    // Null-terminated array of domain names</div><div class="line">    int h_addrtype;      // host type (AF_INET)</div><div class="line">    int h_length;        // length of addr in bytes</div><div class="line">    char **h_addr_list;  // Null-terminated array of in_addr strcuts</div><div class="line">&#125;</div><div class="line">struct  hostent * gethostbyname(const char* name);</div><div class="line">strcut hostent *gethostbtaddr(const char* addr,</div><div class="line">				int len(sizeof(addr)),int type(AF_INET))</div><div class="line">success none -null return, else set h_errno</div></pre></td></tr></table></figure>
</li>
<li><p>Socket structure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include&lt;netinet/in.h&gt;</div><div class="line">struct sockaddr&#123;</div><div class="line">	unsigned short sin_family; // address falily (AF_INET)</div><div class="line">    char      sa_data[14];     // address data</div><div class="line">&#125;;</div><div class="line">struct sockaddr_in&#123;</div><div class="line">	unsigned short sin_family;// AF_INET</div><div class="line">    unsigned short sin_port;  // port number</div><div class="line">    unsigned short sin_addr;  //  IP address</div><div class="line">    unsigned char sin_zero[8] // pad</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Socket function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/typs.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int socket(inr domain, SOCK_TREAM, int protoctol);</div><div class="line">成功非负，失败－１</div><div class="line">常规调用　: clinetfd = socket(AF_INET,SOCK_STREAM,0);</div><div class="line">int connect(int sockfd, struct sockaddr * server_addr, int addrlen);</div><div class="line">成功０，失败－１</div><div class="line">connect函数与套接字地址为serv_addr服务器连接，阻塞直到连接成功</div><div class="line">int bind(int sockfd, struct *my_addr, int len);</div><div class="line">success 0,eles -1</div><div class="line">将my_addr服务器套接字地址与套接字描述符sockfd绑定，addrlen = sizeof(sockaddr_in);</div><div class="line">int listen(int sockfd, int backlog);</div><div class="line">成功０，失败－１</div><div class="line">将sockfd从主动套接字转为监听套接字，backlog 设置拒绝连接前的等待队列请求数量</div><div class="line">int accept(int listenfd, struct sockaddr *adr, int * addrlen);</div><div class="line">成功非负，失败－１</div><div class="line">等待到达侦听描述符sockfd的连接请求，将客户端套接字地址写入addr, 并返回已链接符</div></pre></td></tr></table></figure>
</li>
<li><h6 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h6></li>
<li><code>send</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);</div><div class="line">ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen);</div><div class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</div><div class="line">Returns: number of bytes sent if OK, −1 on error</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>sendto</code> 可在无连接端口上指定目标地址</p>
<ul>
<li><code>receive</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);</div><div class="line">ssize_t recvfrom(int sockfd, void *restrict buf, size_t len, int flags, struct sockaddr *restrict addr, socklen_t *restrict addrlen);</div><div class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/09/APUE-Sockets/" itemprop="url">
                  APUE Sockets
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-09T19:28:10+08:00" content="2016-10-09">
              2016-10-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Sockets/" itemprop="url" rel="index">
                    <span itemprop="name">Sockets</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Socket Descriptors<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int socket(int domain, int type, int protocol);</div><div class="line">Returns: file (socket) descriptor if OK, −1 on error</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int shutdown(int sockfd, int how);</div><div class="line">Returns: 0 if OK, −1 on error</div></pre></td></tr></table></figure></p>
<blockquote>
<p>how : SHUT_RD   SHUT_WR     SHOT_RDWR</p>
<ul>
<li>Byte Ordering<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line">uint32_t htonl(uint32_t hostint32);</div><div class="line">$ Returns: 32-bit integer in network byte order</div><div class="line">uint16_t htons(uint16_t hostint16);</div><div class="line">$ Returns: 16-bit integer in network byte order</div><div class="line">uint32_t ntohl(uint32_t netint32);</div><div class="line">$ Returns: 32-bit integer in host byte order</div><div class="line">uint16_t ntohs(uint16_t netint16);</div><div class="line">$ Returns: 16-bit integer in host byte order</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>translate btween binary and text<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line">const char *inet_ntop(int domain, const void *restrict addr,</div><div class="line">char *restrict str, socklen_t size);</div><div class="line">Returns: pointer to address string on success, NULL on error</div><div class="line">int inet_pton(int domain, const char *restrict str,</div><div class="line">void *restrict addr);</div><div class="line">Returns: 1 on success, 0 if the format is invalid, or −1 on error</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>dimain : AF_INET, AF_INET6<br>- </p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/09/APUE-Threads/" itemprop="url">
                  APUE Threads
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-09T10:23:33+08:00" content="2016-10-09">
              2016-10-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Threads/" itemprop="url" rel="index">
                    <span itemprop="name">Threads</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>A thread ID is represented by the pthread_t data type. Implementations are allowed to use a structure to represent the pthread_t data type</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_equal(pthread_t tid1, pthread_t tid2);</div><div class="line">Returns: nonzero if equal, 0 otherwise</div></pre></td></tr></table></figure>
</li>
<li><p>A thread can obtain its own thread ID by calling the pthread_self function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</div><div class="line">Returns: the thread ID of the calling thread</div></pre></td></tr></table></figure>
</li>
<li><p>Thread Creation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int pthread_create(pthread_t *restrict tidp,</div><div class="line">const pthread_attr_t *restrict attr,</div><div class="line">void *(*start_rtn)(void *), void *restrict arg);</div><div class="line">Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Note that the pthread functions usually return an error code when they fail. They don’t set errno like the other POSIX functions.</p>
<ul>
<li>Thread Termination<br>A single thread can exit in three ways, thereby stopping its flow of control, without terminating the entire process.</li>
</ul>
<ol>
<li>return from the start routine. The return value is the thread’s exit code.</li>
<li>be canceled by another thread in the same process.</li>
<li>pthread_exit.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void pthread_exit(void *rval_ptr);</div><div class="line">int pthread_join(pthread_t thread, void **rval_ptr);</div><div class="line">Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<ul>
<li>pthread_cancel: One thread cancel another in the same process <blockquote>
<p>pthread_cancel doesn’t wait for the thread to terminate; it merely makes the request.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,</div><div class="line">const struct timespec *restrict tsptr);</div><div class="line">Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>the timeout value is reached, <code>pthread_mutex_timedlock</code> will return the error code <code>ETIMEDOUT</code> <code>without locking the mutex</code>.</p>
<ul>
<li>Reader–Writer Locks<br><code>hare in read, exclusive in write</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,</div><div class="line">const pthread_rwlockattr_t *restrict attr);</div><div class="line">int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</div><div class="line">int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</div><div class="line">int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</div><div class="line">int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</div><div class="line">All return: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>Cond_wait</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_cond_signal(pthread_cond_t *cond);</div><div class="line">int pthread_cond_broadcast(pthread_cond_t *cond);</div><div class="line">Both return: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Cancel</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_setcancelstate(int state, int *oldstate);</div><div class="line">$ state : PTHREAD_CANCEL_ENABLE/ PTHREAD_CANCEL_DISABLE</div><div class="line">int pthread_setcanceltype(int type, int *oldtype);</div><div class="line"># type : PTHREADCANCEL_DEFERRED / PTHREADCANCEL_ASYNCHRONOUS</div><div class="line">Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Signal</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;semaphore.h&gt;</div><div class="line">int sem_init(sem_t *sem, 0, unsigned int value);</div><div class="line">int sem_wait(sem_t *s)//P</div><div class="line">int sem_post(sem_t *s)//V</div><div class="line">success return 0, else -1</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>线程安全</p>
<blockquote>
<p>不安全函数类</p>
<ol>
<li>不保护共享变量</li>
<li>保持跨越多个调用状态的函数　：非原子操作</li>
<li>返回指向静态变量指针的函数　：某个线程的返回覆盖其他线程的调用</li>
<li>调用线程部不安全函数<ul>
<li>调用２类线程一定不安全,只能重写保证线程安全</li>
<li>调用１，３类时，用互斥所保护共享变量则线程安全</li>
</ul>
</li>
</ol>
<ul>
<li>reentrant funtion : never change any shared-variables.</li>
<li>reentrant funtion is a subset of thread-safe funtion</li>
<li>some thread-safe funtion may be not reentrant.</li>
</ul>
<p><code>none-thread-safe library funtions</code></p>
<ul>
<li>rand</li>
<li>strtok</li>
<li>asctime</li>
<li>ctime</li>
<li>gethostbyaddr/gethostbyname</li>
<li>int_ntoa</li>
<li>locatime</li>
</ul>
<p><strong>互斥锁加锁，同时占用s,t两个锁的线程必须以相同顺序给s,t加锁</strong></p>
</blockquote>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/01/Programming-With-POSIX-Threads/" itemprop="url">
                  Programming With POSIX Threads
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-01T13:06:18+08:00" content="2016-10-01">
              2016-10-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4> Chapter One </h4>

<blockquote>
<ul>
<li><code>Asynchronous</code>: two operation proceed independently of each other.</li>
<li><code>thread</code>: just a more way to <code>make application asynchronous</code></li>
<li><code>concurency</code> does <code>not imply</code> that the  <code>operations proceed simultaneously</code></li>
<li><code>concurrency</code> allows application to <code>take adcantage of asynchronous capabilities</code> and “do work” while independent operations are proceeding.</li>
<li>并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。</li>
<li>并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。</li>
<li><code>Reentrant code</code> should <code>avoid relying on static data</code> and, ideally, should <code>avoid reliance on any form of synchronization</code> between threads.</li>
<li>A system’s scheduling facility may allow each thread to run until it voluntarily yields the processor to another thread <code>(&quot;run until block&quot;)</code>.</li>
<li>It may provide time-slicing, where each thread is forced to periodically yield so that other threads may run `(“round-robin”)</li>
</ul>
</blockquote>
<ul>
<li>A thread may have o processor status and coprocessor control registers. </li>
<li>A thread does not include most of the rest of the state associated with a process; </li>
<li>threads do not have their own file descriptors or address space.</li>
</ul>
<blockquote>
<p><strong>gcc thread.c -o thread -lpthread</strong></p>
</blockquote>
<ul>
<li><p>For very <code>simple applications</code> ,<code>an event-based implementation</code> may be <code>simpler</code> than the <code>multiprocess or multithread variations</code></p>
</li>
<li><p>Some advantages of the multithreaded programming model follow:</p>
<blockquote>
<ol>
<li>Exploitation of program parallelism on multiprocessor hardware. Parallelism is the only benefit that requires special hardware. The others can help most programs without specialhardware.</li>
<li>More efficient exploitation of a program’s natural concurrency, by allowing the programto perform computations while waiting for slow I/O operations to complete.</li>
<li>A modular programming model that clearly expresses relationships between independent “events” within the program. These advantages are detailed in the following sections.</li>
</ol>
</blockquote>
</li>
<li><p>It is easy to lose performance by using too much synchronization;</p>
</li>
<li>The performance suffers when the <code>multithreaded implementation</code> adds <code>threadsynchronization</code> and <code>scheduling overhead</code> to the work you are to accomplish.</li>
<li><h5 id="Your-most-powerful-and-portable-thread-debugging-tool-is-your-mind"><a href="#Your-most-powerful-and-portable-thread-debugging-tool-is-your-mind" class="headerlink" title="Your most powerful and portable thread debugging tool is your mind"></a><code>Your most powerful and portable thread debugging tool is your mind</code></h5></li>
</ul>
<h4> Chapter Two </h4>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">pthread_t thread;</div><div class="line">int pthread_equal (pthread_t t1, pthread_t t2); </div><div class="line">//compare two thread identifiers</div><div class="line">int pthread_create (pthread_t *thread, const pthread_attr_t *attr, void *(*start)(void *),void *arg);</div><div class="line">pthread_t pthread_self (void);</div><div class="line">//get its own identifier using the pthread\_self function</div><div class="line">//returns a nonzero value if refer to the same thread,  0 if not the same </div><div class="line">int sched_yield (void);</div><div class="line">int pthread_exit (void *value_ptr);</div><div class="line">int pthread_detach (pthread_t thread);</div><div class="line">int pthread_join (pthread_t thread, void **value_ptr);</div></pre></td></tr></table></figure>
<ul>
<li>The initial thread is special because the process terminates without allowing other threads to complete</li>
<li>Detaching a thread tells the system that you no longer need that thread, and allows the system to reclaim the resources allocated to the thread.</li>
<li>Returning from main will cause the process to terminate, along with all threads.</li>
<li><p>code the main thread to terminate by calling pthread_exit, which would allow the process to continue until all threads have terminated.</p>
<blockquote>
<p>The most important thing to remember about thread creation is that there is no synchronization between the creating thread’s return from pthread_create and the scheduling of the new thread. That is, the thread may start before the creating thread returns. The thread may even run to completion and terminate before pthread_create returns</p>
</blockquote>
</li>
<li><p>pthread_join is a convenience, not a rule.</p>
<blockquote>
<p>it is often at least as simple to create the thread detached and devise your own customized return mechanism as it is to use pthread_join. For example, broadcast a condition variable when done.</p>
</blockquote>
</li>
</ul>
<h4> Chapter Three </h4>

<ul>
<li><code>Critical sections</code>  “serial regions” :  areas of code that <code>affect a shared state</code>.</li>
<li><p>The most common and general way to <code>synchronize between threads</code> is to ensure that <code>all memory accesses to the same (or related) data</code> are “<code>mutually exclusive</code>.”</p>
</li>
<li><p>Creating and destroying a mutex</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_t mutex = PTHREAD_MUNEX_INITIALIZER;</div><div class="line">int pthread_mutex_init (pthread_mitex_t *mutex, pthread_mutexattr_t *attr);</div><div class="line">int pthread_mutex_destroy (pthread_mutex_t *mutex);</div></pre></td></tr></table></figure>
</li>
<li><p>never make a copy of a mutex, the result of using a copied mutex is undefined.</p>
</li>
<li>It is a good idea to <code>associate a mutex clearly with the data</code> it protects, if possible, by keeping the definition of the mutex and data together</li>
<li>it is safe (and a good idea) to <code>unlock and destroy the mutex</code> before <code>freeing the storage that the mutex occupies</code>.</li>
<li>the <code>mutex dynamically initialized</code> by calling <code>pthread_mutex_init</code> should <code>destroyed</code>  by calling <code>pthread_mutex_destroy</code>. but a mutex that was <code>statically initialized</code> using the <code>PTHREAD_MUTEX_INITIALIZER</code> macro <code>not</code>, wihch will be destroyed automatically.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int pthread_mutex_lock (pthread_mutex_t *mutex);</div><div class="line">int pthread_mutex_trylock (pthread_mutex_t *mutex);</div><div class="line">int pthread_mutex_unlock (pthread_mutex_t *mutex);</div></pre></td></tr></table></figure>
<blockquote>
<p>pthread_mutex_trylock function will return an error status (EBUSY) instead of blocking if the mutex is already locked.</p>
</blockquote>
<ul>
<li>A condition variable wait always returns with the mutex locked</li>
<li>The mutex must always be locked when you wait on a condition variable</li>
</ul>
<p><strong>Creating and destroying a condition variable</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</div><div class="line">int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *condattr);</div><div class="line">int pthread_cond_destroy (pthread_cond_t *cond);</div></pre></td></tr></table></figure></p>
<ol>
<li><code>cond_wait</code> 等待信号量，若未收到信号量，<code>解锁mutex，并挂起到相应信号量等待队列</code>原子操作(<code>cond\_wait 不返回处于等待信号量状态，不占用CPU</code>)</li>
<li>收到信号量，<code>尝试上锁mutex</code>，若锁被占用则等待，直到获得锁,若上锁成功，进入临界区使用条件变量</li>
<li>由外部<code>unlock</code>完成解锁</li>
</ol>
<p><strong>Waiting on a condition variable</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex);</div><div class="line">int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex, struct timespec *expiration);</div></pre></td></tr></table></figure></p>
<ul>
<li>Each condition variable must be associated with a specific mutex, and with a predicate condition.</li>
<li>That is, each condition variable must be associated, at any given time, with only one mutex–but a mutex may have any number of condition variables associated with it.</li>
</ul>
<p><strong>Waking condition variable waiters</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int pthread_cond_signal (pthread_cond_t *cond);</div><div class="line">int pthread_cond_broadcast (pthread_cond_t *cond);</div></pre></td></tr></table></figure>
</blockquote>
<h4> Chapter five </h4>

<ul>
<li><code>once initialize</code><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pthread_once_t once_control = PTHREAD_ONCE_INIT;</div><div class="line">int pthread_once (pthread_once_t *once_control, void(*init_routine) (void));</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>First, you declare a <code>control variable</code> of type <code>pthread_once_t</code>. The control variable must be <code>statically initialized</code> using the <code>PTHREAD_ONCE_INIT</code> macro, </li>
<li>You must also create a <code>function</code> containing the <code>code to perform all initialization</code> that is to be associated with the control variable.</li>
<li>Now, at any time, a thread may call pthread_once, specifying a pointer to the control variable and a pointer to the associated initialization function.</li>
<li>only the <code>first call</code> <code>pthread_once</code> will <code>successfully initialized</code>．</li>
</ul>
</blockquote>
<ul>
<li><code>Mutex attributes</code><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pthread_mutexattr_t attr;</div><div class="line">int pthread_mutexattr_init &#123; pthread_mutexattr_t *attr);</div><div class="line">int pthread_mutexattr_destroy (pthread_mutexattr_t *attr);</div><div class="line">\#ifdef _POSIX_THREAD PROCESS SHARED</div><div class="line">int pthread_mutexattr_getpshared (pthread_mutexattr_t  *attr, int *pshared);</div><div class="line">int pthread_mutexattr_setpshared (pthread_mutexattr_t *attr, int pshared);</div><div class="line">endif</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">#include &quot;errors.h&quot;</div><div class="line">pthread_mutex_t mutex;</div><div class="line">int main (int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    pthread_mutexattr_t mutex_attr;</div><div class="line">    int status;</div><div class="line">    status = pthread_mutexattr_init (&amp; mutex\_attr);</div><div class="line">    if (status != 0)</div><div class="line">        err_abort (status, &quot;Create attr&quot;);</div><div class="line">#ifdef _POSIX_THREAD_PROCESS_SHARED</div><div class="line">    status = pthread_mutexattr_setpshared (</div><div class="line">        &amp; mutex\_attr, PTHREAD_PROCESS_PRIVATE);</div><div class="line">    if (status != 0)err_abort (status, &quot;Set pshared&quot;);</div><div class="line">#endif</div><div class="line">    status = pthread_mutex_init (&amp;mutex, &amp;mutex_attr);</div><div class="line">    if (status != 0)</div><div class="line">        err_abort (status, &quot;Init mutex&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>Condition variable attributes</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pthread_condattr_t attr;</div><div class="line">int pthread_condattr_init (pthread_condattr_t *attr);</div><div class="line">int pthread_condattr_destroy (pthread_condattr_t *attr);</div><div class="line">#ifdef _POSIX_THREAD_PROCESS_SHARED</div><div class="line">int pthread_condattr_getpshared(pthread_condattr_t *attr, int *pshared);</div><div class="line">int pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared);</div><div class="line">#endif</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Thread attributes</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">pthread_attr_t attr;</div><div class="line">int pthread_attr_init (pthread_attr_t *attr);</div><div class="line">int pthread_attr_destroy (pthread_attr_t *attr);</div><div class="line">int pthread_attr_getdetachstate (pthread_attr_t *attr, int *detachstate);</div><div class="line">int pthread_attr_setdetachstate (pthread_attr_t *attr, int detachstate);</div><div class="line">#ifdef _POSIX_THREAD_ATTR_STACKSISE</div><div class="line">int pthread_attr_getstacksize (pthread_attr_t *attr, size_t *stacksize);</div><div class="line">int pthreae_attr_setstacksize (pthread_attr_t *attr, size_t stacksize);</div><div class="line">#endif</div><div class="line">#ifdef _POSIX_THREAD_ATTR_STACKADDR</div><div class="line">int pthread_attr_getstarkaddr (pthread_attr_t *attr, void *stackaddr);</div><div class="line">int pthread_attr_set-tackaddr (pthread_attr_t *attr, void **stackaddr);</div><div class="line">#endif</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Cancellation</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int pthread_cancel (pthread_t thread);</div><div class="line">int pthread_setcancelstate (int state, int * oldstate);</div><div class="line">int pthread_setcanceltype (int type, int *oldstate);</div><div class="line">void pthread_testcancel (void);</div><div class="line">void pthread_cleanup_push (void (*routine)(void *), void *arg);</div><div class="line">void pthread_cleanup_pop (int execute);</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Creating thread-specific data</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pthread_key_t key;</div><div class="line">int pthread_key_create (pthread_key_t *key, void (*destructor)(void *));</div><div class="line">int pthread_key_delete (pthread_key_t key);</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>you should never delete a thread-specific data key until you are sure that no existing threads have a value for that key,</li>
<li><code>Using thread-specific data</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int pthread_setspecific (pthread_key_t key, const void *value);</div><div class="line">void *pthread_getspecific (pthread_key_t key);</div></pre></td></tr></table></figure>
<ul>
<li>Pthreads will not call the destructor for a thread-specific data key if the terminating thread has a value of NULL for that key.</li>
</ul>
</blockquote>
<ul>
<li><code>Using destructor functions</code><blockquote>
<ul>
<li>If your <code>key&#39;s value</code> is <code>a pointer to heap memory</code>, you will need to <code>free the memory</code> to <code>avoid a memory leak</code> each time a thread terminates.Pthreads allows you to <code>define a destructor function</code> when you create a thread-specific data key. When a <code>thread terminates</code> with a <code>non-NULL value</code> for a <code>thread-specific data key</code>, the <code>key&#39;s destructor</code> (if any) is called with the current value of the key.</li>
<li>the <code>order</code> in which <code>destructors are called</code> is undefined. Try to <code>make each destructor</code> as <code>independent</code> as possible.</li>
</ul>
</blockquote>
</li>
<li><code>Scheduling policies and priorities</code><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int sched_get_priority_max (int policy);</div><div class="line">int sched_get_priority_min (int policy);</div><div class="line">int pthread_attr_getinheritsched( const pthread_attr_t *attr, int *inheritsched);</div><div class="line">int pthread_attr_setinheritsched( pthread_attr_t *attr, int inheritsched);</div><div class="line">int pthread_attr_getschedparam (const pthread_attr_t *attr, struct sched_param *param);</div><div class="line">int pthread_attr_setschedparam ( pthread_attr_t *attr, const struct sched_param *param);</div><div class="line">int pthread_attr_getschedpolicy (const pthread_attr_t *attr, int *policy);</div><div class="line">int pthread_attr_setschedpolicy (pthread_attr_t *attr, int policy);</div><div class="line">int pthread_getschedparam (pthread_t thread, int *policy, struct sched_param *param);</div><div class="line">int pthread_setschedparam (pthread_t thread; int policy; const struct sched_param *param);</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>When you set the scheduling policy or priority attributes in an attributes object, you must also set the inheritsched attribute!</li>
<li>Pthreads does not specify a default value for inheritsched</li>
</ul>
</blockquote>
<p><code>Priority inversion is when a low-priority thread can prevent a high-priority thread from running</code></p>
<h4>POSIX adjusts to threads</h4>

<ul>
<li><p><code>fork</code></p>
<blockquote>
<ul>
<li>When <code>a threaded process</code> calls <code>fork</code> to create <code>a child process</code>, Pthreads specifies that <code>only the thread calling fork exists in the child</code>.</li>
<li>the thread has the same thread state as in the parent</li>
<li>you use fork to clone a threaded program, beware that you may lose access to memory, especially heap memory stored only as thread-specific data values.</li>
<li>a mutex was locked at the time of the call to fork, then it is still locked in the child. Because a locked mutex is owned by the thread that locked it, the mutex can be unlocked in the child only if the thread that locked the mutex was the one that called fork. This is important to remember–if another thread has a mutex locked when you call fork, you will lose access to that mutex and any data controlled by that mutex.</li>
</ul>
</blockquote>
</li>
<li><p><code>Avoid using fork inthreaded code except where the child process will immediately exec a new program.</code></p>
</li>
<li><p><code>Calling pthread_exit from main will terminate the initial thread without affecting the other threads in the process, allowing them to continue and complete normally.</code></p>
</li>
<li><p><code>flockfile and funlockfile</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void flockfile (FILE *file);</div><div class="line">int ftrylockfile (FILE *file);</div><div class="line">void funlockfile (FILE *file);</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>getchar_unlocked and putchar_unlocked</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int getc_unlocked (FILE *stream);</div><div class="line">int getchar_unlocked (void);</div><div class="line">int putc_unlocked (int c, FILE *stream);</div><div class="line">int putchar_unlocked (int c)</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p></p><h4>Hints to avoid debugging</h4><p></p>
<blockquote>
<ul>
<li>Never assume that a thread you create will wait for you.</li>
<li>Thread inertia is a special case of thread races.</li>
<li>thread races that the “loser” generally wins because the memory system will keep the last value written to an address.</li>
<li><p><code>No ordering exists between threads</code></p>
</li>
<li><p>Scheduling exists to tell the system how important a specific job (thread) is to yourapplication so it can schedule the job you need the most. </p>
</li>
<li>Synchronization exists to tell the system that no other thread can be allowed into the critical section until the calling thread is done.</li>
</ul>
</blockquote>
<ul>
<li>Cooperate to avoid deadlocks<blockquote>
<p>One common cause of a deadlock is that some thread has returned from a function without unlocking a mutex</p>
</blockquote>
</li>
<li>Beware of priority inversion</li>
<li>Never share condition variables between predicates<blockquote>
<p>The best solution, when you really want to share a condition variable between predicates, is always to use pthread_cond_broadcast. But when you broadcast, all waiting threads wake up to reevaluate their predicates.</p>
</blockquote>
</li>
<li>Sharing stacks and related memory corrupters<blockquote>
<p>Having carefully ensured that there is no possible way for the owning thread to pop the stack data while other threads are using the shared data</p>
</blockquote>
</li>
<li>Beware of concurrent serialization</li>
<li>Use the right number of mutexes<blockquote>
<p>A common strategy is to create a separate mutex for each data structure, and use those mutexes to serialize access to the shared data, rather than using the “big mutex” to serialize access to the library.</p>
<ul>
<li>you may decrease the efficiency of the memory system by excessive locking</li>
</ul>
</blockquote>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="TheOneAC" />
          <p class="site-author-name" itemprop="name">TheOneAC</p>
          <p class="site-description motion-element" itemprop="description">生如逆旅  一苇可航</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/TheOneAc" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:scuhss@Gamil.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.quora.com/profile/SCUhss-%E9%BB%84%E5%B8%85" target="_blank" title="Quora">
                  
                    <i class="fa fa-fw fa-comments"></i>
                  
                  Quora
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/huang-shuai-4" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016.7.14 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TheOneAC</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
