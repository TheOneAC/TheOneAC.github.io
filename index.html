<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="7989000bfd4e43ea" />










  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Algorithm Git C++" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="生如逆旅  一苇可航">
<meta property="og:type" content="website">
<meta property="og:title" content="TheOneAC">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="TheOneAC">
<meta property="og:description" content="生如逆旅  一苇可航">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TheOneAC">
<meta name="twitter:description" content="生如逆旅  一苇可航">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> TheOneAC </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">TheOneAC</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">init</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/leetcode279-Perfect-Squares-basic-dp/" itemprop="url">
                  leetcode279. Perfect Squares(basic dp)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-11-26T22:03:54+08:00" content="2016-11-26">
              2016-11-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/OJ/" itemprop="url" rel="index">
                    <span itemprop="name">OJ</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="learn-from-this"><a href="#learn-from-this" class="headerlink" title="learn from this"></a>learn from <a href="https://discuss.leetcode.com/topic/24255/summary-of-4-different-solutions-bfs-dp-static-dp-and-mathematics" target="_blank" rel="external">this</a></h3><ul>
<li><p>DP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int numSquares(int n) &#123;</div><div class="line">        if(n&lt;=0)return 0;</div><div class="line">        int * dp = new int[n+1]();</div><div class="line">        for(int i=1;i&lt;=n;i++)&#123;</div><div class="line">            dp[i]= INT_MAX;</div><div class="line">            for(int j =1;j*j &lt;=i;j++)&#123;</div><div class="line">                int tmp = dp[i-j*j]+1;</div><div class="line">                dp[i]=dp[i]&lt;tmp?dp[i]:tmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //for(int i=0;i&lt;=n;i++)cout&lt;&lt; dp[i]&lt;&lt;&apos; &apos;;</div><div class="line">        return dp[n];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>BFS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int numSquares(int n) &#123;</div><div class="line">        if (n &lt;= 0)return 0;</div><div class="line">        else if(pow((int)sqrt(n),2) == n)return 1;</div><div class="line">        vector&lt;int&gt; perfectSquares;//candinates</div><div class="line">        vector&lt;int&gt; cntPerfectSquares(n);//count_index</div><div class="line">        for (int i = 1; i*i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            perfectSquares.push_back(i*i);</div><div class="line">            cntPerfectSquares[i*i - 1] = 1;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        queue&lt;int&gt; searchQ;</div><div class="line">        for (auto&amp; i : perfectSquares) searchQ.push(i);</div><div class="line">        int currCntPerfectSquares = 1;</div><div class="line">        while (!searchQ.empty())//BFS</div><div class="line">        &#123;</div><div class="line">            currCntPerfectSquares++;</div><div class="line">            </div><div class="line">            int searchQSize = searchQ.size();</div><div class="line">            for (int i = 0; i &lt; searchQSize; i++)</div><div class="line">            &#123;</div><div class="line">                int tmp = searchQ.front();</div><div class="line">                for (auto&amp; j : perfectSquares)</div><div class="line">                &#123;</div><div class="line">                    if (tmp + j == n)return currCntPerfectSquares;</div><div class="line">                    else if ((tmp + j &lt; n) &amp;&amp; (cntPerfectSquares[tmp + j - 1] == 0))</div><div class="line">                    &#123;</div><div class="line">                        cntPerfectSquares[tmp + j - 1] = currCntPerfectSquares;</div><div class="line">                        searchQ.push(tmp + j);</div><div class="line">                    &#125;</div><div class="line">                    else if (tmp + j &gt; n)break;</div><div class="line">                &#125;</div><div class="line">                searchQ.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/Object Oriented in C++/" itemprop="url">
                  Object Oriented in C++
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-11-26T22:00:54+08:00" content="2016-11-26">
              2016-11-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>定义<code>const</code> 成员函数时,<code>const</code> 位于<code>参数</code>与<code>函数体</code>之间</li>
<li><code>const</code>成员函数只能调用 <code>const</code>成员函数,保证不做修改</li>
<li><code>禁用默认函数</code>(构造,赋值构造等),将<code>默认函数私有化</code>private</li>
<li><code>const</code>成员变量只能<code>参数列表初始化</code></li>
<li>成员函数内部<code>static</code>变量为<code>所有调用该成员函数的对象共有</code></li>
<li><code>this</code>指针<code>不用于static 成员函数</code>中,<code>不能指向const 对象</code></li>
<li>隐藏的父类成员,子类不可直接调用,通过父类共有函数调用</li>
<li><code>派生类同名成员或者函数 屏蔽父类同名成员或者函数</code></li>
<li>为<code>基类设置默认构造函数</code>,方便子类继承</li>
<li>基类声明虚函数后,<code>子类同名</code>自动定义为<code>虚函数</code></li>
<li>构造函数<code>不可以是虚成员函数</code>, <code>析构函数</code>可以</li>
<li><code>重载</code>在<code>编译时期绑定</code>,<code>虚函数(多态)</code> <code>运行期间绑定</code></li>
<li><code>覆盖</code>:多态虚函数函数签名相同,  <code>遮蔽</code>: 共享函数名但签名不同</li>
<li><code>抽象基类确保派生类必须定义某些特定函数（纯虚函数）</code>，否则派生类不可以实例化</li>
<li>抽象基类：<code>包含一个纯虚函数　　virtual    =0;</code></li>
<li><p><code>抽象基类不可实例化</code>，可派生，其<code>派生类必须覆盖全部纯虚函数</code>才可被实例化</p>
</li>
<li><p>重载不改变符号优先级</p>
</li>
<li>除<code>new new[] delete delete[]</code>外以顶层函数重载操作符必须包含一个类对象</li>
<li>操作符<code>[] ()　-&gt;</code>必须以<code>类成员形式重载</code></li>
<li>以成员函数重载二元操作符，只需一个参数，而以顶层函数重载二元操作符时必须两个参数</li>
<li>使用<code>顶层函数重载非对象操作数可出现在操作符左边</code>，<code>类成员函数重载</code>时<code>第一个操作数必须是类对象</code><br>-　<code>praivete member</code> only access by <code>menberfunction and friend funtion.</code></li>
<li><code>protect member</code> can be accessed by <code>menber funtion</code>, <code>friend function</code> and <code>member function of derived class</code></li>
<li>using <code>friend function</code> <code>only</code> in <code>overloading operator</code> as possible as we can</li>
<li>前置自增：　operator++()     后置自增：　operator++(int );</li>
<li><code>new new[]</code>  <code>return type</code> must be <code>void*</code>, the first parameter must be <code>size_t</code></li>
<li><code>delete delete[]</code> return type must be <code>void*</code>, the first parameter must be <code>void *</code> wihch point to the object need to destroied</li>
<li><p>对象不能属于模板类，只能属于模板类实例</p>
</li>
<li><p>duque :双端插入删除效率一致，vector 尾部插入删除效率高</p>
</li>
<li><code>protect</code>成员只能被<code>该类和子类的方法访问</code></li>
<li>父类成员必须定义默认构造函数，否则子类构造前出现编译错误</li>
<li>同一域名空间，函数名相同，签名不同</li>
<li>编译期绑定确定绑定函数，也称为静态多态<h4 id="重写-覆盖-override"><a href="#重写-覆盖-override" class="headerlink" title="重写:覆盖(override)"></a>重写:覆盖(override)</h4></li>
<li>虚函数</li>
<li>子类空间，函数名相同，签名相同<h4 id="重定义：遮蔽（redefine）"><a href="#重定义：遮蔽（redefine）" class="headerlink" title="重定义：遮蔽（redefine）"></a>重定义：遮蔽（redefine）</h4></li>
<li>非虚函数，子类成员函数与父类成员函数同名</li>
<li>虚函数，子类成员函数与父类成员函数同名但不同签名<h4 id="多态：（动态多态）"><a href="#多态：（动态多态）" class="headerlink" title="多态：（动态多态）"></a>多态：（动态多态）</h4></li>
<li>运行期确定绑定对象，也称为动态多态</li>
<li>同签名虚函数构成覆盖</li>
<li>父类指针指向子类对象，调用属于子类的函数</li>
</ul>
<hr>
<ul>
<li>顶层函数重载操作符<ul>
<li>非对象操作数可以出现在操作符左边</li>
<li>使用类成员函数重载是，第一操作数必须是累的对象</li>
<li>顶层函数不能直接访问类私有成员，最好将顶层重载函数设为友元函数，方便直接访问私有数据成员</li>
</ul>
</li>
<li>重载[]:  重载为成员函数，检查下标 ， 返回一个引用适应左值情况</li>
<li>重载（）： 函数调用重载操作符</li>
<li>析构函数出现，必须定义拷贝构造，赋值构造函数</li>
</ul>
<hr>
<ul>
<li>继承下的构造函数：<ul>
<li>先父类按继承顺序构造，再成员按顺序构造，最后派生类构造</li>
<li>每一层只负责调用父类构造函数</li>
<li>基类没有默认构造时，子类构造函数必须显式调用基类的某个构造函数</li>
<li>创建派生类对象时，自动调用基类默认构造函数<ul>
<li>子类有构造函数，基类没有默认构造，创建子类对象时，自动创建基类默认构造函数</li>
<li>子类没有构造函数，基类有默认构造，创建子类对象时，自动调用基类默认构造</li>
<li>子类有构造函数，基类也有默认构造，创建子类对象时，直接调用基类默认构造，或者调用子类显式调用的构造函数</li>
<li>子类基类均有构造，但是基类没有默认构造，创建子类对象时，必须显式调用基类构造函数</li>
</ul>
</li>
</ul>
</li>
<li>继承下的析构函数: 定义实现对派生类新增成员的析构释放</li>
<li>虚基类构造优先于非虚基类的构造</li>
<li>虚基类构造由最派生类调用，其他派生类跳过对虚基类构造的调用</li>
<li>派生类对象和指针可适用于任何基类对象或指针使用的位置（子类可以向上转型）</li>
<li>赋值兼容：子类对象可以赋值或者初始化父类对象，基类指针可以指向子类对象地址</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/25/TCP协议簇/" itemprop="url">
                  TCP协议簇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-25T10:41:48+08:00" content="2016-10-25">
              2016-10-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h4><blockquote>
<h6 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h6><ul>
<li>比特流传输</li>
<li>比特同步、物理拓扑</li>
<li>传输方式：半双工、双工<h6 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h6></li>
<li>节点间帧传输</li>
<li>组帧</li>
<li>加入物理地址</li>
<li>流量控制：发送速度小于接受速度</li>
<li>接入控制：决定链路控制权</li>
<li>确保组网内部节点间传递<h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6></li>
<li>确保源点到终点间的分组交付</li>
<li>路由选择</li>
<li>点点交付<h6 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h6></li>
<li>报文源点到终点的端端交付</li>
<li>分段与重装<h6 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h6></li>
<li>会话控制与同步<h6 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h6></li>
<li>编码转换</li>
<li>信息加密与压缩<h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6></li>
<li>虚拟终端</li>
<li>文件传输与管理</li>
<li>邮件服务和名录服务<br><img src="http://odfcr7qs4.bkt.clouddn.com/%E5%9B%BE2.14.PNG" alt="图2.14"></li>
<li>以太网数据帧长46~1500字节</li>
<li>隐蔽站问题：先发一个请求服务帧（RTS），请求服务时间，接收站广播(CTS)在服务时间内只为请求站服务</li>
<li>中继器：连接同一子网的不同网段</li>
<li>集线器：多端口转发</li>
<li>网桥：工作在链路层，检查MAC地址，过滤帧转发地址</li>
<li>透明网桥： 帧转发，自学习，避免环路</li>
<li>路由器转发会修改物理地址，工作在网络层，<ul>
<li>整个传递过程目的IP地址不变</li>
<li>路由器接受前，目的物理地址是路由器地址</li>
<li>接收后转发，源物理地址是路由器物理地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">网络地址：主机位全0</div><div class="line">直接广播地址：主机位全1</div><div class="line">受限广播地址：全1</div><div class="line">这个网络这个主机：全0</div><div class="line">这个网络特定主机：网络位全0</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>路由表</p>
<ul>
<li>目的网络地址：使用特定网络地址转发</li>
<li>下一跳地址：直接交付时为空</li>
<li>接口位置：定义转发接口</li>
<li>目的地址查找成功，ARP映射获得物理地址，帧转发到下一跳<pre><code>        OP 源MAC 源IP 目的MAC 目的IP
ARP请求： 1  *      *            *
ARP响应： 2  *      *     *      *
RARP请求： 3  *
RARP响应： 4  *      *     *      *
</code></pre><img src="http://odfcr7qs4.bkt.clouddn.com/%E5%9B%BE8.10IP%E9%80%89%E9%A1%B9.PNG" alt="图8.10IP选项格式"><br>IP报文总长20~65535，首部长：20~60字节<br>总长以1字为单位，首部 长以4字节为单位<br>分片偏移以8字为单位，相对于原始数据包起点</li>
<li>IP协议字段：1 ICMP 2 IGMP 6 TCP 17：UDP 89 OSPF<br><img src="http://odfcr7qs4.bkt.clouddn.com/%E5%9B%BE9.1ICMP%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B.PNG" alt="图9.1ICMP报文类型"></li>
<li>差错报文发送给原始数据源</li>
<li>对差错报文不再发送差多报文</li>
<li>对多播报文不发送差错报文</li>
<li>分片数据报的非首片不发送差错报文</li>
<li>特殊地址数据报不发送差错报文<br>每一个因为拥塞丢弃的报文都向源点发送源点抑制报文<br>ICMP协议为IP协议提供：</li>
<li>差错报告、差错控制（重点不可达，超时、源点抑制、参数问题、改变路由）、</li>
<li>主机管理查询（回送送请求和响应、时间戳请求与响应）、</li>
<li>流量控制（源点抑制报文）服务</li>
</ul>
</blockquote>
<p>发送超时报文：</p>
<ul>
<li>（路由器发送）收到的报文TTL字段为0，</li>
<li>（目的主机发送）规定时间内未收到报文的某个分片<br>改变路由报文：路由器向主机发送改变路由报文<br>回送请求和回送回答报文用于测试主机可达性确认网络层通信是否正常<br>时间戳请求与回答：确认往返时间，机器间时间同步<br>ping利用回送请求与响应报文实现<br>traceroute利用超时报文（中间TTL减少至0，路由器发回超时）和终点不可达报文（UDP端口异常）</li>
<li>ICMP 报文类型：查询、成员关系报告、推出报告</li>
<li>成员关系报告需要连续发送两次</li>
<li>成员关系报告：加入组</li>
<li>退出报告：退出一个组</li>
<li>一般性查询：多播路由器周期性发送以监视成员关系</li>
<li>延迟响应：主机等待随机时间，该时间内若有成员关系报告广播，就不再对这个组发送成员关系响应广播<br>携带ICMP报文的IP报文中：协议字段为2，TTL必须是1（局域网内）<br>目的IP地址：查询（多播）：224.0.0.1，成员关系报告（广播）：这个组的多播地址，退出报告（多播）：224.0.0.2<br>####### 数据链路层MAC地址映射：</li>
<li>多播路由器提取D类IP地址的低23位插入以太网多播地址中</li>
<li>D类IP地址组标识共28位，取23位映射以太网多播地址，位未使用，32-&gt;1</li>
<li>以太网多播地址范围：01:00:5E:00:00:00 ~ 01:00:5E:7F:FF:FF</li>
<li>广域网不支持物理多播地址，只能采用隧道技术，封装成单播，到达局域网后解析成多播<br>####### UDP<br>熟知端口号:0~1023,注册端口号：1024~49151，动态端口号：49152~65535<br>UDP长度 = IP长度-IP首部长度<h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6></li>
<li>编号从随机数开始</li>
<li>报文序号：首字节序号</li>
<li>确认号：期望接收的下一个序号</li>
<li>SYN 和SYN+ACK报文不携带数据，消耗一个序号</li>
<li>ACK不携带数据则不消耗序号<br><img src="" alt="12.9"><br><img src="" alt="12.11"></li>
<li>FIN不消耗序号，FIN+ACK只消耗一个序号</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/APUE-Process/" itemprop="url">
                  APUE Process
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-10T16:40:03+08:00" content="2016-10-10">
              2016-10-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Process/" itemprop="url" rel="index">
                    <span itemprop="name">Process</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="chapter-seven"><a href="#chapter-seven" class="headerlink" title="chapter seven"></a>chapter seven</h5><ul>
<li><p>Process tremination</p>
<blockquote>
<ul>
<li>Return from main</li>
<li>Calling exit</li>
<li>Calling _exit or _Exit</li>
<li>Return of the last thread from its start routine</li>
<li>Calling pthread_exit</li>
<li>from the last thread</li>
</ul>
<ul>
<li><code>Abnormal termination occurs in three ways:</code><ul>
<li>Calling abort (Section 10.17)</li>
<li>Receipt of a signal (Section 10.2)</li>
<li>Response of the last thread to a cancellation request</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>Exit Functions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">void exit(int status);</div><div class="line">void _Exit(int status);</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">void _exit(int status);</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>_exit</code> and <code>_Exit</code>, which <code>return</code> to the kernel <code>immediately</code>, and <code>exit</code>, which <code>performs certain cleanup processing</code>and then returns to the kernel.</p>
</blockquote>
<ul>
<li>atexit()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">int atexit(void (*func)(void));</div><div class="line">Returns: 0 if OK, nonzero on error</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li>a process can register at least 32 functions that are automatically called by exit. These are called exit handlers and are registered by calling the atexit function.</li>
<li>The exit function calls these functions in reverse order of their registration.</li>
<li>Each function is called as many times as it was registered.</li>
<li>Environment List<br><img src="" alt="Environment"><br>the environment strings are typically stored at the top<br>of a process’s memory space, above the stack.</li>
</ul>
</blockquote>
<h5 id="chapter-eight"><a href="#chapter-eight" class="headerlink" title="chapter eight"></a>chapter eight</h5><ul>
<li>pid_t<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">pid_t getpid(void);</div><div class="line">Returns: process ID of calling process</div><div class="line">pid_t getppid(void);</div><div class="line">Returns: parent process ID of calling process</div><div class="line">uid_t getuid(void);</div><div class="line">Returns: real user ID of calling process</div><div class="line">uid_t geteuid(void);</div><div class="line">Returns: effective user ID of calling process</div><div class="line">gid_t getgid(void);</div><div class="line">Returns: real group ID of calling process</div><div class="line">gid_t getegid(void);</div><div class="line">Returns: effective group ID of calling process</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a><code>fork</code></h4><p>-　调用一次，返回两次，子进程返回０，　父进程返回子线程pid<br>-　子进程只保留调用fork 的线程副本<br>-　父进程中所有打开的文件描述符被复制到子进程<br>-　子进程不集成父进程的文件锁，<code>未处理闹钟清除，未处理信号集置空</code><br>-　父进程先于子进程结束，子进程被<code>init</code>进程收养，其父进程ＩＤ为１<br>-　已经结束但未被父进程处理的进程：<code>僵死进程</code></p>
<h4 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait waitpid"></a><code>wait</code> <code>waitpid</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">pid_t wait(int *statloc);</div><div class="line">pid_t waitpid(pid_t pid, int *statloc, int options);</div><div class="line">Both return: process ID if OK, 0 (see later), or −1 on error</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>wait or waitpid do<br>• <code>Block</code>, if <code>all of its children are still running</code><br>• <code>Return immediately</code> with the termination status of <code>a child</code>, if a child has terminated and is waiting for its termination status to be fetched<br>• <code>Return immediately with an error</code>, if it <code>doesn’t have any child</code> processes</li>
<li>OSIX.1 waitpid function.<br>The interpretation of the pid argument for waitpid depends on its value:</li>
<li>pid == −1  <code>Waits for any child process</code>. In this respect, waitpid is equivalent to wait.</li>
<li>pid &gt; 0 <code>Waits for the child whose process ID equals pid</code>.</li>
<li>pid == 0 Waits for <code>any child</code> whose process <code>group ID</code> equals that of the calling process.</li>
<li>pid &lt; −1 Waits for <code>any child</code> whose process <code>group ID</code> equals the absolute value of pid</li>
</ul>
</blockquote>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int execl(const char *pathname, const char *arg0, ... /* (char *)0 */ );</div><div class="line">int execv(const char *pathname, char *const argv[]);</div><div class="line">int execle(const char *pathname, const char *arg0, ...</div><div class="line">/* (char *)0, char *const envp[] */ );</div><div class="line">int execve(const char *pathname, char *const argv[], char *const envp[]);</div><div class="line">int execlp(const char *filename, const char *arg0, ... /* (char *)0 */ );</div><div class="line">int execvp(const char *filename, char *const argv[]);</div><div class="line">int fexecve(int fd, char *const argv[], char *const envp[]);</div><div class="line">All seven return: −1 on error, no return on success</div></pre></td></tr></table></figure>
<blockquote>
<p><code>l</code> stands for <code>list</code>, <code>v</code> stands for <code>vector</code>, <code>e</code> stands for <code>environment</code><br>The functions <code>execl, execlp, and execle</code> require <code>each of the
command-line arguments</code> to the new program to be specified as separate arguments. We <code>mark the end of the arguments</code> with <code>a null pointer</code>.<br>For the other four functions (<code>execv, execvp, execve, and fexecve</code>), build an array of pointers to the arguments, and <code>the address of this array</code> pass to these three functions.<br><img src="" alt="exec"></p>
</blockquote>
<h4 id="Process-schedule"><a href="#Process-schedule" class="headerlink" title="Process schedule"></a><code>Process schedule</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int nice(int incr);</div><div class="line">#include &lt;sys/resource.h&gt;</div><div class="line">int getpriority(int which, id_t who);</div><div class="line">Returns: new nice value − NZERO if OK, −1 on error</div><div class="line">#include &lt;sys/resource.h&gt;</div><div class="line">int setpriority(int which, id_t who, int value);</div><div class="line">Returns: 0 if OK, −1 on error</div></pre></td></tr></table></figure>
<blockquote>
<p>which : PRO_PROCESS , PRO_GROUP, PRO_USER</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/Network-programming-csapp/" itemprop="url">
                  Network programming csapp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-10T11:19:22+08:00" content="2016-10-10">
              2016-10-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Network-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Network Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>IP 地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct in_addr&#123;</div><div class="line">	unsigned int s_addr</div><div class="line">&#125;</div><div class="line">#include &lt;netinet/in.h&gt;</div><div class="line">unsigned long int  htonl(unsigned long int hostlong);</div><div class="line">unsigned short int  htons(unsigned short int hostshort);</div><div class="line">本地转网络字节序</div><div class="line">unsigned long int ntohl(unsigned long int hostlong);</div><div class="line">unsigned short int ntohs(unsigned short int hostlong);</div><div class="line">网络转本地字节</div><div class="line">均以无符号数转换</div><div class="line">网络字节摩恩为：大端，即有效地位存放在地址高位</div><div class="line">＃include&lt;arpa/inet.h&gt;</div><div class="line">int inet_aton((const char*cp, struct in_addr *inp);</div><div class="line">点分十进制串(cp)转网络字节序IP(inp)</div><div class="line">int inet_ntoa (struct in_addr in);</div><div class="line">网络字节序IP 转点分十进制</div></pre></td></tr></table></figure>
</li>
<li><p>Domain structure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;netdb.h&gt;</div><div class="line">struct host&#123;</div><div class="line">	char *h_name;        // domain name</div><div class="line">    char **h_aliases;    // Null-terminated array of domain names</div><div class="line">    int h_addrtype;      // host type (AF_INET)</div><div class="line">    int h_length;        // length of addr in bytes</div><div class="line">    char **h_addr_list;  // Null-terminated array of in_addr strcuts</div><div class="line">&#125;</div><div class="line">struct  hostent * gethostbyname(const char* name);</div><div class="line">strcut hostent *gethostbtaddr(const char* addr,</div><div class="line">				int len(sizeof(addr)),int type(AF_INET))</div><div class="line">success none -null return, else set h_errno</div></pre></td></tr></table></figure>
</li>
<li><p>Socket structure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include&lt;netinet/in.h&gt;</div><div class="line">struct sockaddr&#123;</div><div class="line">	unsigned short sin_family; // address falily (AF_INET)</div><div class="line">    char      sa_data[14];     // address data</div><div class="line">&#125;;</div><div class="line">struct sockaddr_in&#123;</div><div class="line">	unsigned short sin_family;// AF_INET</div><div class="line">    unsigned short sin_port;  // port number</div><div class="line">    unsigned short sin_addr;  //  IP address</div><div class="line">    unsigned char sin_zero[8] // pad</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Socket function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/typs.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int socket(inr domain, SOCK_TREAM, int protoctol);</div><div class="line">成功非负，失败－１</div><div class="line">常规调用　: clinetfd = socket(AF_INET,SOCK_STREAM,0);</div><div class="line">int connect(int sockfd, struct sockaddr * server_addr, int addrlen);</div><div class="line">成功０，失败－１</div><div class="line">connect函数与套接字地址为serv_addr服务器连接，阻塞直到连接成功</div><div class="line">int bind(int sockfd, struct *my_addr, int len);</div><div class="line">success 0,eles -1</div><div class="line">将my_addr服务器套接字地址与套接字描述符sockfd绑定，addrlen = sizeof(sockaddr_in);</div><div class="line">int listen(int sockfd, int backlog);</div><div class="line">成功０，失败－１</div><div class="line">将sockfd从主动套接字转为监听套接字，backlog 设置拒绝连接前的等待队列请求数量</div><div class="line">int accept(int listenfd, struct sockaddr *adr, int * addrlen);</div><div class="line">成功非负，失败－１</div><div class="line">等待到达侦听描述符sockfd的连接请求，将客户端套接字地址写入addr, 并返回已链接符</div></pre></td></tr></table></figure>
</li>
<li><h6 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h6></li>
<li><code>send</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);</div><div class="line">ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen);</div><div class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</div><div class="line">Returns: number of bytes sent if OK, −1 on error</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><code>sendto</code> 可在无连接端口上指定目标地址</p>
<ul>
<li><code>receive</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);</div><div class="line">ssize_t recvfrom(int sockfd, void *restrict buf, size_t len, int flags, struct sockaddr *restrict addr, socklen_t *restrict addrlen);</div><div class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/09/APUE-Sockets/" itemprop="url">
                  APUE Sockets
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-09T19:28:10+08:00" content="2016-10-09">
              2016-10-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Sockets/" itemprop="url" rel="index">
                    <span itemprop="name">Sockets</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Socket Descriptors<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int socket(int domain, int type, int protocol);</div><div class="line">Returns: file (socket) descriptor if OK, −1 on error</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int shutdown(int sockfd, int how);</div><div class="line">Returns: 0 if OK, −1 on error</div></pre></td></tr></table></figure></p>
<blockquote>
<p>how : SHUT_RD   SHUT_WR     SHOT_RDWR</p>
<ul>
<li>Byte Ordering<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line">uint32_t htonl(uint32_t hostint32);</div><div class="line">$ Returns: 32-bit integer in network byte order</div><div class="line">uint16_t htons(uint16_t hostint16);</div><div class="line">$ Returns: 16-bit integer in network byte order</div><div class="line">uint32_t ntohl(uint32_t netint32);</div><div class="line">$ Returns: 32-bit integer in host byte order</div><div class="line">uint16_t ntohs(uint16_t netint16);</div><div class="line">$ Returns: 16-bit integer in host byte order</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>translate btween binary and text<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line">const char *inet_ntop(int domain, const void *restrict addr,</div><div class="line">char *restrict str, socklen_t size);</div><div class="line">Returns: pointer to address string on success, NULL on error</div><div class="line">int inet_pton(int domain, const char *restrict str,</div><div class="line">void *restrict addr);</div><div class="line">Returns: 1 on success, 0 if the format is invalid, or −1 on error</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>dimain : AF_INET, AF_INET6<br>- </p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/09/APUE-Threads/" itemprop="url">
                  APUE Threads
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-09T10:23:33+08:00" content="2016-10-09">
              2016-10-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Threads/" itemprop="url" rel="index">
                    <span itemprop="name">Threads</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>A thread ID is represented by the pthread_t data type. Implementations are allowed to use a structure to represent the pthread_t data type</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_equal(pthread_t tid1, pthread_t tid2);</div><div class="line">Returns: nonzero if equal, 0 otherwise</div></pre></td></tr></table></figure>
</li>
<li><p>A thread can obtain its own thread ID by calling the pthread_self function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</div><div class="line">Returns: the thread ID of the calling thread</div></pre></td></tr></table></figure>
</li>
<li><p>Thread Creation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int pthread_create(pthread_t *restrict tidp,</div><div class="line">const pthread_attr_t *restrict attr,</div><div class="line">void *(*start_rtn)(void *), void *restrict arg);</div><div class="line">Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Note that the pthread functions usually return an error code when they fail. They don’t set errno like the other POSIX functions.</p>
<ul>
<li>Thread Termination<br>A single thread can exit in three ways, thereby stopping its flow of control, without terminating the entire process.</li>
</ul>
<ol>
<li>return from the start routine. The return value is the thread’s exit code.</li>
<li>be canceled by another thread in the same process.</li>
<li>pthread_exit.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void pthread_exit(void *rval_ptr);</div><div class="line">int pthread_join(pthread_t thread, void **rval_ptr);</div><div class="line">Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<ul>
<li>pthread_cancel: One thread cancel another in the same process <blockquote>
<p>pthread_cancel doesn’t wait for the thread to terminate; it merely makes the request.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,</div><div class="line">const struct timespec *restrict tsptr);</div><div class="line">Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>the timeout value is reached, <code>pthread_mutex_timedlock</code> will return the error code <code>ETIMEDOUT</code> <code>without locking the mutex</code>.</p>
<ul>
<li>Reader–Writer Locks<br><code>hare in read, exclusive in write</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,</div><div class="line">const pthread_rwlockattr_t *restrict attr);</div><div class="line">int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</div><div class="line">int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</div><div class="line">int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</div><div class="line">int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</div><div class="line">All return: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li><p>Cond_wait</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_cond_signal(pthread_cond_t *cond);</div><div class="line">int pthread_cond_broadcast(pthread_cond_t *cond);</div><div class="line">Both return: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Cancel</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">int pthread_setcancelstate(int state, int *oldstate);</div><div class="line">$ state : PTHREAD_CANCEL_ENABLE/ PTHREAD_CANCEL_DISABLE</div><div class="line">int pthread_setcanceltype(int type, int *oldtype);</div><div class="line"># type : PTHREADCANCEL_DEFERRED / PTHREADCANCEL_ASYNCHRONOUS</div><div class="line">Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Signal</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;semaphore.h&gt;</div><div class="line">int sem_init(sem_t *sem, 0, unsigned int value);</div><div class="line">int sem_wait(sem_t *s)//P</div><div class="line">int sem_post(sem_t *s)//V</div><div class="line">success return 0, else -1</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>线程安全</p>
<blockquote>
<p>不安全函数类</p>
<ol>
<li>不保护共享变量</li>
<li>保持跨越多个调用状态的函数　：非原子操作</li>
<li>返回指向静态变量指针的函数　：某个线程的返回覆盖其他线程的调用</li>
<li>调用线程部不安全函数<ul>
<li>调用２类线程一定不安全,只能重写保证线程安全</li>
<li>调用１，３类时，用互斥所保护共享变量则线程安全</li>
</ul>
</li>
</ol>
<ul>
<li>reentrant funtion : never change any shared-variables.</li>
<li>reentrant funtion is a subset of thread-safe funtion</li>
<li>some thread-safe funtion may be not reentrant.</li>
</ul>
<p><code>none-thread-safe library funtions</code></p>
<ul>
<li>rand</li>
<li>strtok</li>
<li>asctime</li>
<li>ctime</li>
<li>gethostbyaddr/gethostbyname</li>
<li>int_ntoa</li>
<li>locatime</li>
</ul>
<p><strong>互斥锁加锁，同时占用s,t两个锁的线程必须以相同顺序给s,t加锁</strong></p>
</blockquote>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/01/Programming-With-POSIX-Threads/" itemprop="url">
                  Programming With POSIX Threads
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-01T13:06:18+08:00" content="2016-10-01">
              2016-10-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4> Chapter One </h4>

<blockquote>
<ul>
<li><code>Asynchronous</code>: two operation proceed independently of each other.</li>
<li><code>thread</code>: just a more way to <code>make application asynchronous</code></li>
<li><code>concurency</code> does <code>not imply</code> that the  <code>operations proceed simultaneously</code></li>
<li><code>concurrency</code> allows application to <code>take adcantage of asynchronous capabilities</code> and “do work” while independent operations are proceeding.</li>
<li>并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。</li>
<li>并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。</li>
<li><code>Reentrant code</code> should <code>avoid relying on static data</code> and, ideally, should <code>avoid reliance on any form of synchronization</code> between threads.</li>
<li>A system’s scheduling facility may allow each thread to run until it voluntarily yields the processor to another thread <code>(&quot;run until block&quot;)</code>.</li>
<li>It may provide time-slicing, where each thread is forced to periodically yield so that other threads may run `(“round-robin”)</li>
</ul>
</blockquote>
<ul>
<li>A thread may have o processor status and coprocessor control registers. </li>
<li>A thread does not include most of the rest of the state associated with a process; </li>
<li>threads do not have their own file descriptors or address space.</li>
</ul>
<blockquote>
<p><strong>gcc thread.c -o thread -lpthread</strong></p>
</blockquote>
<ul>
<li><p>For very <code>simple applications</code> ,<code>an event-based implementation</code> may be <code>simpler</code> than the <code>multiprocess or multithread variations</code></p>
</li>
<li><p>Some advantages of the multithreaded programming model follow:</p>
<blockquote>
<ol>
<li>Exploitation of program parallelism on multiprocessor hardware. Parallelism is the only benefit that requires special hardware. The others can help most programs without specialhardware.</li>
<li>More efficient exploitation of a program’s natural concurrency, by allowing the programto perform computations while waiting for slow I/O operations to complete.</li>
<li>A modular programming model that clearly expresses relationships between independent “events” within the program. These advantages are detailed in the following sections.</li>
</ol>
</blockquote>
</li>
<li><p>It is easy to lose performance by using too much synchronization;</p>
</li>
<li>The performance suffers when the <code>multithreaded implementation</code> adds <code>threadsynchronization</code> and <code>scheduling overhead</code> to the work you are to accomplish.</li>
<li><h5 id="Your-most-powerful-and-portable-thread-debugging-tool-is-your-mind"><a href="#Your-most-powerful-and-portable-thread-debugging-tool-is-your-mind" class="headerlink" title="Your most powerful and portable thread debugging tool is your mind"></a><code>Your most powerful and portable thread debugging tool is your mind</code></h5></li>
</ul>
<h4> Chapter Two </h4>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">pthread_t thread;</div><div class="line">int pthread_equal (pthread_t t1, pthread_t t2); </div><div class="line">//compare two thread identifiers</div><div class="line">int pthread_create (pthread_t *thread, const pthread_attr_t *attr, void *(*start)(void *),void *arg);</div><div class="line">pthread_t pthread_self (void);</div><div class="line">//get its own identifier using the pthread\_self function</div><div class="line">//returns a nonzero value if refer to the same thread,  0 if not the same </div><div class="line">int sched_yield (void);</div><div class="line">int pthread_exit (void *value_ptr);</div><div class="line">int pthread_detach (pthread_t thread);</div><div class="line">int pthread_join (pthread_t thread, void **value_ptr);</div></pre></td></tr></table></figure>
<ul>
<li>The initial thread is special because the process terminates without allowing other threads to complete</li>
<li>Detaching a thread tells the system that you no longer need that thread, and allows the system to reclaim the resources allocated to the thread.</li>
<li>Returning from main will cause the process to terminate, along with all threads.</li>
<li><p>code the main thread to terminate by calling pthread_exit, which would allow the process to continue until all threads have terminated.</p>
<blockquote>
<p>The most important thing to remember about thread creation is that there is no synchronization between the creating thread’s return from pthread_create and the scheduling of the new thread. That is, the thread may start before the creating thread returns. The thread may even run to completion and terminate before pthread_create returns</p>
</blockquote>
</li>
<li><p>pthread_join is a convenience, not a rule.</p>
<blockquote>
<p>it is often at least as simple to create the thread detached and devise your own customized return mechanism as it is to use pthread_join. For example, broadcast a condition variable when done.</p>
</blockquote>
</li>
</ul>
<h4> Chapter Three </h4>

<ul>
<li><code>Critical sections</code>  “serial regions” :  areas of code that <code>affect a shared state</code>.</li>
<li><p>The most common and general way to <code>synchronize between threads</code> is to ensure that <code>all memory accesses to the same (or related) data</code> are “<code>mutually exclusive</code>.”</p>
</li>
<li><p>Creating and destroying a mutex</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_t mutex = PTHREAD_MUNEX_INITIALIZER;</div><div class="line">int pthread_mutex_init (pthread_mitex_t *mutex, pthread_mutexattr_t *attr);</div><div class="line">int pthread_mutex_destroy (pthread_mutex_t *mutex);</div></pre></td></tr></table></figure>
</li>
<li><p>never make a copy of a mutex, the result of using a copied mutex is undefined.</p>
</li>
<li>It is a good idea to <code>associate a mutex clearly with the data</code> it protects, if possible, by keeping the definition of the mutex and data together</li>
<li>it is safe (and a good idea) to <code>unlock and destroy the mutex</code> before <code>freeing the storage that the mutex occupies</code>.</li>
<li>the <code>mutex dynamically initialized</code> by calling <code>pthread_mutex_init</code> should <code>destroyed</code>  by calling <code>pthread_mutex_destroy</code>. but a mutex that was <code>statically initialized</code> using the <code>PTHREAD_MUTEX_INITIALIZER</code> macro <code>not</code>, wihch will be destroyed automatically.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int pthread_mutex_lock (pthread_mutex_t *mutex);</div><div class="line">int pthread_mutex_trylock (pthread_mutex_t *mutex);</div><div class="line">int pthread_mutex_unlock (pthread_mutex_t *mutex);</div></pre></td></tr></table></figure>
<blockquote>
<p>pthread_mutex_trylock function will return an error status (EBUSY) instead of blocking if the mutex is already locked.</p>
</blockquote>
<ul>
<li>A condition variable wait always returns with the mutex locked</li>
<li>The mutex must always be locked when you wait on a condition variable</li>
</ul>
<p><strong>Creating and destroying a condition variable</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</div><div class="line">int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *condattr);</div><div class="line">int pthread_cond_destroy (pthread_cond_t *cond);</div></pre></td></tr></table></figure></p>
<ol>
<li><code>cond_wait</code> 等待信号量，若未收到信号量，<code>解锁mutex，并挂起到相应信号量等待队列</code>原子操作(<code>cond\_wait 不返回处于等待信号量状态，不占用CPU</code>)</li>
<li>收到信号量，<code>尝试上锁mutex</code>，若锁被占用则等待，直到获得锁,若上锁成功，进入临界区使用条件变量</li>
<li>由外部<code>unlock</code>完成解锁</li>
</ol>
<p><strong>Waiting on a condition variable</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex);</div><div class="line">int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex, struct timespec *expiration);</div></pre></td></tr></table></figure></p>
<ul>
<li>Each condition variable must be associated with a specific mutex, and with a predicate condition.</li>
<li>That is, each condition variable must be associated, at any given time, with only one mutex–but a mutex may have any number of condition variables associated with it.</li>
</ul>
<p><strong>Waking condition variable waiters</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int pthread_cond_signal (pthread_cond_t *cond);</div><div class="line">int pthread_cond_broadcast (pthread_cond_t *cond);</div></pre></td></tr></table></figure>
</blockquote>
<h4> Chapter five </h4>

<ul>
<li><code>once initialize</code><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pthread_once_t once_control = PTHREAD_ONCE_INIT;</div><div class="line">int pthread_once (pthread_once_t *once_control, void(*init_routine) (void));</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>First, you declare a <code>control variable</code> of type <code>pthread_once_t</code>. The control variable must be <code>statically initialized</code> using the <code>PTHREAD_ONCE_INIT</code> macro, </li>
<li>You must also create a <code>function</code> containing the <code>code to perform all initialization</code> that is to be associated with the control variable.</li>
<li>Now, at any time, a thread may call pthread_once, specifying a pointer to the control variable and a pointer to the associated initialization function.</li>
<li>only the <code>first call</code> <code>pthread_once</code> will <code>successfully initialized</code>．</li>
</ul>
</blockquote>
<ul>
<li><code>Mutex attributes</code><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pthread_mutexattr_t attr;</div><div class="line">int pthread_mutexattr_init &#123; pthread_mutexattr_t *attr);</div><div class="line">int pthread_mutexattr_destroy (pthread_mutexattr_t *attr);</div><div class="line">\#ifdef _POSIX_THREAD PROCESS SHARED</div><div class="line">int pthread_mutexattr_getpshared (pthread_mutexattr_t  *attr, int *pshared);</div><div class="line">int pthread_mutexattr_setpshared (pthread_mutexattr_t *attr, int pshared);</div><div class="line">endif</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line">#include &quot;errors.h&quot;</div><div class="line">pthread_mutex_t mutex;</div><div class="line">int main (int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    pthread_mutexattr_t mutex_attr;</div><div class="line">    int status;</div><div class="line">    status = pthread_mutexattr_init (&amp; mutex\_attr);</div><div class="line">    if (status != 0)</div><div class="line">        err_abort (status, &quot;Create attr&quot;);</div><div class="line">#ifdef _POSIX_THREAD_PROCESS_SHARED</div><div class="line">    status = pthread_mutexattr_setpshared (</div><div class="line">        &amp; mutex\_attr, PTHREAD_PROCESS_PRIVATE);</div><div class="line">    if (status != 0)err_abort (status, &quot;Set pshared&quot;);</div><div class="line">#endif</div><div class="line">    status = pthread_mutex_init (&amp;mutex, &amp;mutex_attr);</div><div class="line">    if (status != 0)</div><div class="line">        err_abort (status, &quot;Init mutex&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>Condition variable attributes</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pthread_condattr_t attr;</div><div class="line">int pthread_condattr_init (pthread_condattr_t *attr);</div><div class="line">int pthread_condattr_destroy (pthread_condattr_t *attr);</div><div class="line">#ifdef _POSIX_THREAD_PROCESS_SHARED</div><div class="line">int pthread_condattr_getpshared(pthread_condattr_t *attr, int *pshared);</div><div class="line">int pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared);</div><div class="line">#endif</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Thread attributes</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">pthread_attr_t attr;</div><div class="line">int pthread_attr_init (pthread_attr_t *attr);</div><div class="line">int pthread_attr_destroy (pthread_attr_t *attr);</div><div class="line">int pthread_attr_getdetachstate (pthread_attr_t *attr, int *detachstate);</div><div class="line">int pthread_attr_setdetachstate (pthread_attr_t *attr, int detachstate);</div><div class="line">#ifdef _POSIX_THREAD_ATTR_STACKSISE</div><div class="line">int pthread_attr_getstacksize (pthread_attr_t *attr, size_t *stacksize);</div><div class="line">int pthreae_attr_setstacksize (pthread_attr_t *attr, size_t stacksize);</div><div class="line">#endif</div><div class="line">#ifdef _POSIX_THREAD_ATTR_STACKADDR</div><div class="line">int pthread_attr_getstarkaddr (pthread_attr_t *attr, void *stackaddr);</div><div class="line">int pthread_attr_set-tackaddr (pthread_attr_t *attr, void **stackaddr);</div><div class="line">#endif</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Cancellation</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int pthread_cancel (pthread_t thread);</div><div class="line">int pthread_setcancelstate (int state, int * oldstate);</div><div class="line">int pthread_setcanceltype (int type, int *oldstate);</div><div class="line">void pthread_testcancel (void);</div><div class="line">void pthread_cleanup_push (void (*routine)(void *), void *arg);</div><div class="line">void pthread_cleanup_pop (int execute);</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Creating thread-specific data</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pthread_key_t key;</div><div class="line">int pthread_key_create (pthread_key_t *key, void (*destructor)(void *));</div><div class="line">int pthread_key_delete (pthread_key_t key);</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>you should never delete a thread-specific data key until you are sure that no existing threads have a value for that key,</li>
<li><code>Using thread-specific data</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int pthread_setspecific (pthread_key_t key, const void *value);</div><div class="line">void *pthread_getspecific (pthread_key_t key);</div></pre></td></tr></table></figure>
<ul>
<li>Pthreads will not call the destructor for a thread-specific data key if the terminating thread has a value of NULL for that key.</li>
</ul>
</blockquote>
<ul>
<li><code>Using destructor functions</code><blockquote>
<ul>
<li>If your <code>key&#39;s value</code> is <code>a pointer to heap memory</code>, you will need to <code>free the memory</code> to <code>avoid a memory leak</code> each time a thread terminates.Pthreads allows you to <code>define a destructor function</code> when you create a thread-specific data key. When a <code>thread terminates</code> with a <code>non-NULL value</code> for a <code>thread-specific data key</code>, the <code>key&#39;s destructor</code> (if any) is called with the current value of the key.</li>
<li>the <code>order</code> in which <code>destructors are called</code> is undefined. Try to <code>make each destructor</code> as <code>independent</code> as possible.</li>
</ul>
</blockquote>
</li>
<li><code>Scheduling policies and priorities</code><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int sched_get_priority_max (int policy);</div><div class="line">int sched_get_priority_min (int policy);</div><div class="line">int pthread_attr_getinheritsched( const pthread_attr_t *attr, int *inheritsched);</div><div class="line">int pthread_attr_setinheritsched( pthread_attr_t *attr, int inheritsched);</div><div class="line">int pthread_attr_getschedparam (const pthread_attr_t *attr, struct sched_param *param);</div><div class="line">int pthread_attr_setschedparam ( pthread_attr_t *attr, const struct sched_param *param);</div><div class="line">int pthread_attr_getschedpolicy (const pthread_attr_t *attr, int *policy);</div><div class="line">int pthread_attr_setschedpolicy (pthread_attr_t *attr, int policy);</div><div class="line">int pthread_getschedparam (pthread_t thread, int *policy, struct sched_param *param);</div><div class="line">int pthread_setschedparam (pthread_t thread; int policy; const struct sched_param *param);</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>When you set the scheduling policy or priority attributes in an attributes object, you must also set the inheritsched attribute!</li>
<li>Pthreads does not specify a default value for inheritsched</li>
</ul>
</blockquote>
<p><code>Priority inversion is when a low-priority thread can prevent a high-priority thread from running</code></p>
<h4>POSIX adjusts to threads</h4>

<ul>
<li><p><code>fork</code></p>
<blockquote>
<ul>
<li>When <code>a threaded process</code> calls <code>fork</code> to create <code>a child process</code>, Pthreads specifies that <code>only the thread calling fork exists in the child</code>.</li>
<li>the thread has the same thread state as in the parent</li>
<li>you use fork to clone a threaded program, beware that you may lose access to memory, especially heap memory stored only as thread-specific data values.</li>
<li>a mutex was locked at the time of the call to fork, then it is still locked in the child. Because a locked mutex is owned by the thread that locked it, the mutex can be unlocked in the child only if the thread that locked the mutex was the one that called fork. This is important to remember–if another thread has a mutex locked when you call fork, you will lose access to that mutex and any data controlled by that mutex.</li>
</ul>
</blockquote>
</li>
<li><p><code>Avoid using fork inthreaded code except where the child process will immediately exec a new program.</code></p>
</li>
<li><p><code>Calling pthread_exit from main will terminate the initial thread without affecting the other threads in the process, allowing them to continue and complete normally.</code></p>
</li>
<li><p><code>flockfile and funlockfile</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void flockfile (FILE *file);</div><div class="line">int ftrylockfile (FILE *file);</div><div class="line">void funlockfile (FILE *file);</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>getchar_unlocked and putchar_unlocked</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int getc_unlocked (FILE *stream);</div><div class="line">int getchar_unlocked (void);</div><div class="line">int putc_unlocked (int c, FILE *stream);</div><div class="line">int putchar_unlocked (int c)</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p></p><h4>Hints to avoid debugging</h4><p></p>
<blockquote>
<ul>
<li>Never assume that a thread you create will wait for you.</li>
<li>Thread inertia is a special case of thread races.</li>
<li>thread races that the “loser” generally wins because the memory system will keep the last value written to an address.</li>
<li><p><code>No ordering exists between threads</code></p>
</li>
<li><p>Scheduling exists to tell the system how important a specific job (thread) is to yourapplication so it can schedule the job you need the most. </p>
</li>
<li>Synchronization exists to tell the system that no other thread can be allowed into the critical section until the calling thread is done.</li>
</ul>
</blockquote>
<ul>
<li>Cooperate to avoid deadlocks<blockquote>
<p>One common cause of a deadlock is that some thread has returned from a function without unlocking a mutex</p>
</blockquote>
</li>
<li>Beware of priority inversion</li>
<li>Never share condition variables between predicates<blockquote>
<p>The best solution, when you really want to share a condition variable between predicates, is always to use pthread_cond_broadcast. But when you broadcast, all waiting threads wake up to reevaluate their predicates.</p>
</blockquote>
</li>
<li>Sharing stacks and related memory corrupters<blockquote>
<p>Having carefully ensured that there is no possible way for the owning thread to pop the stack data while other threads are using the shared data</p>
</blockquote>
</li>
<li>Beware of concurrent serialization</li>
<li>Use the right number of mutexes<blockquote>
<p>A common strategy is to create a separate mutex for each data structure, and use those mutexes to serialize access to the shared data, rather than using the “big mutex” to serialize access to the library.</p>
<ul>
<li>you may decrease the efficiency of the memory system by excessive locking</li>
</ul>
</blockquote>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/01/TCPIP-illustraed-V1/" itemprop="url">
                  TCP/IP illustraed V1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-01T11:36:20+08:00" content="2016-10-01">
              2016-10-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><code>IP : unreliable, connectionless datagram delivery service</code></p>
</blockquote>
<ul>
<li>unreliable : when something wrong ,throw away the datagram and try to send ICMP to the source</li>
<li>connectionless : each datagram transfered indepently which may get delivered out of order, not maintain any state information about sucessive datagrams</li>
<li><code>network traverse order</code>is<code>big endian</code> </li>
<li><p>IP rout search : <code>IP address</code> <code>network ID</code> <code>default</code>routing table<br><code>A complete matching host address is searched for before a matching network ID.</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">32-bit IP  ----&gt;  48-bit MAC</div><div class="line">   |       ARP       |</div><div class="line">   |       RARP  	|</div><div class="line">   |&lt;----------------|</div></pre></td></tr></table></figure>
</li>
<li><p>ARP Cache :maintains the recent mapping from IP to hardware address(MAC)</p>
</li>
<li>Proxy ARP :a router answer ARP requests on one of its networks for a host on another of its networks </li>
<li>Gratuitous ARP:a host sends an ARP request looking for its own IP address</li>
</ul>
<p><strong>RARP : use the physical address to get the the IP address</strong></p>
<blockquote>
<ol>
<li>RARP request(broadcast), RARP reply (unicast)</li>
<li>RARP request are sen as hardware-level broadcast, not forward by routers.</li>
<li>multiply RARP server are normally provided on a single nework<br>all the server replys, but the rquest systerm use the first RARP reply that ir receives.</li>
</ol>
</blockquote>
<p><strong>ICMP</strong></p>
<blockquote>
<ul>
<li>ICMP message are transmitted within IP datagrams.</li>
<li>chesum cover the entire message</li>
<li>ICMP donot response to:</li>
</ul>
<ol>
<li>An ICMP error message</li>
<li>A datagram destined to an IP broadcast address.</li>
<li>Datagram sent as a  link-layer broadcast.</li>
<li>A fragment other than the first</li>
<li>A datagram whose source address dose not define a single host.</li>
</ol>
</blockquote>
<p><strong>IP route</strong></p>
<blockquote>
<ul>
<li>netstat -rn<br>U: the route is up;<br>G: the route is to differentiate between an indirect route(G) and a direct route<br>H : specifies the destination address is a complete host address.<ul>
<li>indirect route: IP address specify the destination and the link layer address specifies the gateway.</li>
<li>direct route : both the IP address and the  link-layer address specifies the destinations.</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong> match host -&gt; match subnet -&gt; default gateway</strong></p>
<ul>
<li>The ICMP “host unreachable” error message is sent by a router when it receives an IP datagram that it cannot deliver or forward</li>
<li>The ICMP redirect error is sent by a router to the sender of an IP datagram when the datagram should have been sent to a different router</li>
</ul>
<p><strong>Dynamic route</strong></p>
<ul>
<li>RIP messages are carried in UDP datagrams,<code>port number for RIP is UDP port 520</code><br><img src="http://odfcr7qs4.bkt.clouddn.com/RIP%20in%20UDP.png" alt="RIP in UDP"></li>
</ul>
<blockquote>
<ol>
<li>A stub AS has only a single connection to one other AS. A stub AS carries only local traffic.</li>
<li>A multihomed AS has connections to more than one other AS, but refuses to carry transit traffic.</li>
<li>A transit AS has connections to more than one other AS and is designed, under certain policy restrictions, to carry both local and transit traffic.</li>
</ol>
<p><strong>BGP uses TCP as its transport protocol, distance vector protocol, but ennumberate the route to each destination</strong></p>
</blockquote>
<p><strong>UDP</strong></p>
<ul>
<li>The UDP/TCP c<code>hecksum</code>covers <code>the header and the data,</code>but not IP</li>
<li>both UDP and TCP include a <code>12-byte pseudo-header</code> with the <code>UDP datagram</code> (or TCP segment) just <code>for the checksum computation</code></li>
<li>fragmentation : if <code>one fragment</code> is <code>lost</code> the <code>entire datagram</code> must be <code>retransmitted.</code></li>
<li>An <code>IP datagram</code>is the <code>unit of end to end transmission</code> at IP layer ,but a <code>packet</code> is the unit of data passed between  <code>the IP layer and the link layer</code>.</li>
</ul>
<blockquote>
<p><code>Broadcasting and multicasting only apply to UDP</code></p>
</blockquote>
<p><img src="http://odfcr7qs4.bkt.clouddn.com/D%20IP%20map%20into%20Ethernet%20address.png" alt="Mapping of a class D IP address into Ethernet multicast address"></p>
<p><strong>IGMP</strong></p>
<blockquote>
<ol>
<li>A host sends an IGMP report when the first process joins a group. If multiple processes on a given host join the same group, only one report is sent, the first time a process joins that group. This report is sent out the same interface on which the process joined the group.</li>
<li>A host does not send a report when processes leave a group, even when the last process leaves a group. The host knows that there are no members in a given group, so when it receives the next query (next step), it won’t report the group.</li>
<li>A multicast router sends an IGMP query at regular intervals to see if any hosts still have processes belonging to any groups. The router must send one query out each interface. The group address in the query is 0 since the router expects one response from a host for every group that contains one or more members on that host.</li>
<li>A host responds to an IGMP query by sending one IGMP report for each group that still contains at least one process.</li>
</ol>
<ul>
<li>an application must convert a hostname to an IP address before it can ask TCP to open a connection or send a datagram using UDP. The TCP/IP protocols within the kernel know nothing about the DNS.</li>
</ul>
</blockquote>
<ul>
<li>TFTP use in UDP<blockquote>
<ul>
<li>each exchange start with the clinet asking the server read a file for the clinet or write a file for the client</li>
<li>be used only during the bootstrap process of diskless systems. It uses only a few message formats and a stop-and-wait protocol.</li>
<li>he TFTP server provides concurrency by creating a new UDP port for each client.</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>connection-oriented, reliable, byte stream service</p>
</blockquote>
<p><strong>TCP Interactive Data Flow</strong></p>
<blockquote>
<p>each interactive keystroke normally generates a datapacket in Rlogin</p>
</blockquote>
<p><code>four segments:</code></p>
<blockquote>
<p>(1) the interactive keystroke from the client,<br>(2) anacknowledgment of the keystroke from the server,<br>(3) the echo of the keystroke from the server,<br>(4)an acknowledgment of the echo from the client.</p>
</blockquote>
<p><code>Nagle algorithm</code></p>
<blockquote>
<ul>
<li>a TCP connection can have only one outstanding small segment that has not yet been acknowledged. No additional small segments can be sent until the acknowledgment is received. Instead, small amounts of data are collected by TCP and sent in a single segment when the acknowledgment arrives.</li>
<li>Delayed acknowledgments are used by the receiver of these small segments to see if the acknowledgment can be piggybacked along with data going back to the sender. This often reduces the number of segments, especially for an Rlogin session, where the server is echoing the characters typed at the client.</li>
<li>On slower WANs the Nagle algorithm is often used to reduce the number of these small segments. This algorithm limits the sender to a single small packet of unacknowledged data at any time. But there are times when the Nagle algorithm needs to be disabled, and we showed an example of this.</li>
</ul>
</blockquote>
<ul>
<li>flow control is done by the Rlogin client.</li>
</ul>
<p><strong>SNMP</strong></p>
<blockquote>
<p><code>SNMP uses UDP</code>,a request from the manager may not arrive at the agent, The manager probably wants to implement <code>a timeout and retransmission.</code><br>The manager sends its three <code>requests</code> to <code>UDP port 161</code>. The agent sends <code>traps</code> to <code>UDP port 162</code>.</p>
</blockquote>
<p><img src="http://odfcr7qs4.bkt.clouddn.com/SNMP.png" alt="SNMP"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/23/sctp/" itemprop="url">
                  SCTP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-09-23T18:06:16+08:00" content="2016-09-23">
              2016-09-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="SCTP-流传输控制协议"><a href="#SCTP-流传输控制协议" class="headerlink" title="SCTP : 流传输控制协议"></a>SCTP : 流传输控制协议</h4><ol>
<li>UDP面向报文,保留报文边界,不可靠传输,无流量控制和传输控制</li>
<li>TCP面向字节,不好刘报文边界,可靠传输,拥塞控制和流量控制</li>
<li>面向报文,可靠传输,拥塞控制流量控制</li>
<li>位于网络层与应用之间,全双工</li>
</ol>
<ul>
<li>SCTP 一个关联包含多重流,某一个流堵塞,其他流仍可以交付数据<ul>
<li>TCP只有一个源IP地址和一个目的IP地址</li>
</ul>
</li>
<li>STCP关联支持<code>多重归属服务</code>,正常情况下只有一个路径有效,其他候补;故障时,候补路径补上</li>
<li>STCP 允许每一个端使用多个IP地址</li>
</ul>
<hr>
<ul>
<li>SCTP使用<code>传输序号TSN</code>对数据块编号,TSN累计编号</li>
<li><code>流标识符SI</code>区分一个关联内的流</li>
<li><code>流序号SSN</code>区分同一个流中不同数据块</li>
</ul>
<hr>
<ul>
<li>STCP报头定长１２字节，<code>序号.确认号.窗口大小</code>放在控制块中</li>
<li>一个分组多个数据块，分属于不同流</li>
<li>STCP确认号面向数据块，位于控制信息中，<code>只用来确认数据块</code></li>
<li>控制块位于数据块之前</li>
<li>通用首部：１６位源端口地址，１６位目的端口地址，３２位验证标志，３２位检验和</li>
<li>DATA数据块内容只能属于一个数据块，一个报文可以分割为多个数据块</li>
</ul>
<hr>
<p><strong>关联建立</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">INIT          Init tag:1200 rwnd:1000 Init TSN:1000   VT:0</div><div class="line">INITACK       Init tag:5000 rwnd:2000 Init TSN:1700   VT:1200</div><div class="line">COOKIE ECHO   cookie  VT:5000</div><div class="line">COOKIEACK     VT:1200</div><div class="line">＊　INIT. INITACK 不携带其他块，COOKIE ECHO. COOKIE ACK 可以携带数据块 `</div></pre></td></tr></table></figure></p>
<ul>
<li>只有DATA块消耗TSN, DATA 块是唯一可确认的块<br><strong>关联终止</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SHUTDOWN          VT:x   cum :TSN</div><div class="line">SHUTDOWN ACK      VT:y</div><div class="line">SHUTDOWN COMPLETE VT:x</div></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="TheOneAC" />
          <p class="site-author-name" itemprop="name">TheOneAC</p>
          <p class="site-description motion-element" itemprop="description">生如逆旅  一苇可航</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">33</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/TheOneAc" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:scuhss@Gamil.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.quora.com/profile/SCUhss-%E9%BB%84%E5%B8%85" target="_blank" title="Quora">
                  
                    <i class="fa fa-fw fa-comments"></i>
                  
                  Quora
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/huang-shuai-4" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016.7.14 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TheOneAC</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
